/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2019-12-19 23:33:34.826275
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKcos(j[2]);
x3=IKsin(j[0]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKsin(j[1]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKsin(j[6]);
x11=IKcos(j[5]);
x12=IKcos(j[6]);
x13=IKsin(j[5]);
x14=((1.0)*x6);
x15=((1.0)*x5);
x16=((1.0)*x4);
x17=((0.32)*x6);
x18=((1.0)*x8);
x19=((0.2255)*x9);
x20=((1.0)*x13);
x21=((1.0)*x2);
x22=((1.0)*x11);
x23=((0.2255)*x5);
x24=((1.0)*x9);
x25=((0.2255)*x8);
x26=((0.2255)*x6);
x27=(x4*x7);
x28=(x2*x7);
x29=(x0*x7);
x30=(x3*x7);
x31=(x0*x4);
x32=(x1*x3);
x33=(x0*x2);
x34=(x0*x1);
x35=(x16*x3);
x36=(x1*x14);
x37=(x30*x6);
x38=(x15*x29);
x39=(x15*x30);
x40=(x14*x30);
x41=((((-1.0)*x35))+((x1*x33)));
x42=(((x2*x32))+x31);
x43=((((-1.0)*x16*x32))+x33);
x44=(x35+(((-1.0)*x21*x34)));
x45=((((-1.0)*x21*x3))+(((-1.0)*x16*x34)));
x46=(x41*x6);
x47=((((-1.0)*x0*x16))+(((-1.0)*x21*x32)));
x48=(((x1*x15))+((x14*x28)));
x49=((-1.0)*x48);
x50=(x43*x8);
x51=((1.0)*x45);
x52=(x45*x9);
x53=(x48*x9);
x54=(x45*x8);
x55=(x49*x8);
x56=((((-1.0)*x38))+x46);
x57=((((-1.0)*x39))+((x42*x6)));
x58=((((-1.0)*x14*x29))+((x44*x5)));
x59=((((-1.0)*x14*x42))+x39);
x60=(((x27*x9))+x55);
x61=(x56*x8);
x62=(x57*x8);
x63=(x13*x58);
x64=(x59*x9);
x65=(x62+((x43*x9)));
x66=(((x20*((x36+(((-1.0)*x28*x5))))))+(((-1.0)*x22*x60)));
x67=(((x20*(((((-1.0)*x47*x5))+x40))))+(((-1.0)*x22*x65)));
eerot[0]=(((x12*((((x11*((x52+x61))))+x63))))+((x10*((((x9*(((((-1.0)*x46))+x38))))+x54)))));
eerot[1]=(((x10*((((x11*((((x8*(((((-1.0)*x29*x5))+x46))))+x52))))+x63))))+(((-1.0)*x12*((((x18*x45))+((x24*(((((-1.0)*x14*x41))+x38)))))))));
eerot[2]=(((x11*x58))+((x13*(((((-1.0)*x18*x56))+(((-1.0)*x24*x45)))))));
IkReal x68=((1.0)*x29);
eetrans[0]=((((-1.0)*x17*x68))+((x13*(((((-1.0)*x19*x45))+(((-1.0)*x25*x56))))))+((x11*((((x23*x44))+(((-1.0)*x26*x68))))))+((x5*(((((-0.32)*x1*x33))+(((0.32)*x3*x4))))))+(((-0.33)*x29)));
eerot[3]=(((x12*x67))+((x10*(((((-1.0)*x50))+(((-1.0)*x64)))))));
eerot[4]=(((x12*((x50+x64))))+((x10*x67)));
eerot[5]=(((x13*x65))+((x11*(((((-1.0)*x15*x47))+x40)))));
eetrans[1]=(((x13*((((x19*x43))+((x25*x57))))))+((x17*x30))+(((0.33)*x30))+((x5*(((((0.32)*x2*x32))+(((0.32)*x31))))))+((x11*((((x26*x30))+(((-1.0)*x23*x47)))))));
eerot[6]=(((x12*x66))+((x10*(((((-1.0)*x24*x48))+(((-1.0)*x16*x7*x8)))))));
eerot[7]=(((x10*x66))+((x12*((((x27*x8))+x53)))));
eerot[8]=(((x13*x60))+((x11*(((((-1.0)*x15*x28))+x36)))));
eetrans[2]=((0.3705)+((x13*((((x19*x27))+((x25*x49))))))+((x1*x17))+(((0.33)*x1))+((x11*((((x1*x26))+(((-1.0)*x23*x28))))))+(((-0.32)*x28*x5)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {1}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j1,cj1,sj1,htj1,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij1[2], _nj1;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij1[0] = -1; _ij1[1] = -1; _nj1 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j1=pfree[0]; cj1=cos(pfree[0]); sj1=sin(pfree[0]), htj1=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=((-1.0)*r01);
new_r02=((-1.0)*r02);
new_px=(px+(((-0.2255)*r02)));
new_r10=((-1.0)*r10);
new_r11=r11;
new_r12=r12;
new_py=((((-1.0)*py))+(((0.2255)*r12)));
new_r20=((-1.0)*r20);
new_r21=r21;
new_r22=r22;
new_pz=((0.3705)+(((-1.0)*pz))+(((0.2255)*r22)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x69=((1.0)*px);
IkReal x70=((1.0)*pz);
IkReal x71=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x71))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x70)));
rxp0_2=((((-1.0)*r10*x69))+((py*r00)));
rxp1_0=((((-1.0)*r21*x71))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x70)));
rxp1_2=((((-1.0)*r11*x69))+((py*r01)));
rxp2_0=((((-1.0)*r22*x71))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x70)));
rxp2_2=((((-1.0)*r12*x69))+((py*r02)));
{
IkReal j0eval[4];
IkReal x72=sj1*sj1;
j0eval[0]=(((x72*(px*px)))+((x72*(py*py))));
j0eval[1]=0.4356;
j0eval[2]=sj1;
j0eval[3]=(pp+(((-1.0)*(pz*pz))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x73=((0.32)*r22);
IkReal x74=((1.0)*pz);
IkReal x75=((0.33)*cj1);
IkReal x76=pz*pz;
IkReal x77=(pz*r22);
IkReal x78=((0.64)*x77);
IkReal x79=(pz*x74);
IkReal x80=((-1.0)*pz);
IkReal x81=(x75+x74);
IkReal x82=(x73+(((-1.0)*x81)));
IkReal x83=((((-1.0)*x73))+(((-1.0)*x81)));
IkReal x84=((0.0065)+(((-1.0)*x78))+(((-1.0)*x79)));
IkReal x85=((0.0065)+(((-1.0)*x79))+x78);
px=0;
py=0;
pp=x76;
npx=(pz*r20);
npy=(pz*r21);
npz=x77;
rxp0_0=(pz*r10);
rxp0_1=(r00*x80);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x80);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x80);
rxp2_2=0;
IkReal gconst0=x83;
IkReal gconst1=x82;
IkReal gconst2=x84;
IkReal gconst3=x85;
IkReal gconst4=x83;
IkReal gconst5=x82;
IkReal gconst6=x84;
IkReal gconst7=x85;
IkReal gconst8=x83;
IkReal gconst9=x82;
IkReal gconst10=x84;
IkReal gconst11=x85;
IkReal gconst12=x83;
IkReal gconst13=x82;
IkReal gconst14=x84;
IkReal gconst15=x85;
IkReal x86=pz*pz;
IkReal x87=pz*pz*pz;
IkReal x88=r22*r22;
IkReal x89=cj1*cj1;
IkReal x90=pz*pz*pz*pz;
IkReal x91=r20*r20;
IkReal x92=r21*r21;
IkReal x93=(r20*r21);
IkReal x94=((0.003514368)*pz);
IkReal x95=(cj1*x91);
IkReal x96=((1.6384)*x90);
IkReal x97=((0.540672)*x87);
IkReal x98=(cj1*x87);
IkReal x99=(cj1*x88);
IkReal x100=(x86*x89);
IkReal x101=(x90*x91);
IkReal x102=(x86*x92);
IkReal x103=(x86*x88);
IkReal x104=(pz*x99);
IkReal x105=(x88*x90);
IkReal x106=(cj1*pz*x92);
IkReal x107=(x86*x91);
IkReal x108=((((0.71368704)*x100*x93))+(((0.014057472)*cj1*pz*x93))+((x93*x96))+(((6.92224e-5)*x93))+(((0.0212992)*x86*x93))+(((2.162688)*x93*x98)));
j6eval[0]=((((0.5)*(IKabs(((((-1.0)*x95*x97))+(((-1.0)*x94*x95))+(((-1.0)*x94*x99))+(((-0.4096)*x101))+(((-0.4096)*x105))+(((-0.17842176)*x100*x91))+(((-0.17842176)*x100*x88))+(((-0.0053248)*x107))+(((-0.0053248)*x103))+(((-1.73056e-5)*x88))+(((-1.73056e-5)*x91))+(((-1.0)*x97*x99)))))))+(((2.0)*(IKabs(x108))))+(IKabs(((((-0.014057472)*x104))+(((-0.014057472)*x106))+(((-0.71368704)*x100*x92))+(((-0.71368704)*x100*x88))+(((-0.0212992)*x103))+(((-0.0212992)*x102))+(((-2.162688)*x92*x98))+(((-6.92224e-5)*x88))+(((-6.92224e-5)*x92))+(((-1.0)*x92*x96))+(((-2.162688)*x88*x98))+(((-1.0)*x88*x96)))))+(((0.5)*(IKabs(((((3.46112e-5)*x91))+(((0.35684352)*x100*x91))+(((-4.325376)*x92*x98))+(((-2.4576)*x105))+(((-1.42737408)*x100*x92))+(((-0.0001038336)*x88))+(((-3.2768)*x90*x92))+(((-0.021086208)*x104))+(((-0.0319488)*x103))+(((-0.0001384448)*x92))+(((-0.0425984)*x102))+(((0.8192)*x101))+(((-3.244032)*x88*x98))+(((0.007028736)*pz*x95))+(((1.081344)*x87*x95))+(((0.0106496)*x107))+(((-0.028114944)*x106))+(((-1.07053056)*x100*x88))))))));
if( IKabs(j6eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j0, j5, j6]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x109=r20*r20;
IkReal x110=pz*pz;
IkReal x111=r21*r21;
IkReal x112=(gconst11*gconst6);
IkReal x113=(gconst0*gconst5);
IkReal x114=(gconst0*gconst11);
IkReal x115=((1.0)*gconst12);
IkReal x116=((1.6384)*gconst3);
IkReal x117=(gconst1*gconst14);
IkReal x118=(gconst13*gconst14);
IkReal x119=(gconst11*gconst14);
IkReal x120=(gconst12*gconst3);
IkReal x121=(gconst7*gconst8);
IkReal x122=(gconst15*gconst3);
IkReal x123=(gconst1*gconst6);
IkReal x124=(r20*r21);
IkReal x125=(gconst11*gconst12);
IkReal x126=((3.2768)*pz);
IkReal x127=((1.0)*gconst4);
IkReal x128=(gconst1*gconst10);
IkReal x129=(gconst12*gconst7);
IkReal x130=((3.2768)*gconst4);
IkReal x131=(gconst3*gconst4);
IkReal x132=((1.6384)*gconst12);
IkReal x133=(gconst15*gconst4);
IkReal x134=(gconst14*gconst3);
IkReal x135=(gconst5*gconst8);
IkReal x136=(gconst14*gconst9);
IkReal x137=(gconst6*gconst9);
IkReal x138=(gconst4*gconst7);
IkReal x139=(gconst11*gconst4);
IkReal x140=(gconst2*gconst9);
IkReal x141=(gconst10*gconst9);
IkReal x142=(gconst3*gconst6);
IkReal x143=((1.6384)*gconst4);
IkReal x144=(gconst1*gconst2);
IkReal x145=(gconst12*gconst15);
IkReal x146=((1.0)*gconst2);
IkReal x147=(gconst13*gconst8);
IkReal x148=(gconst0*gconst3);
IkReal x149=(gconst0*gconst13);
IkReal x150=((1.6384)*x111);
IkReal x151=(pz*x109);
IkReal x152=((1.0)*gconst10*gconst13);
IkReal x153=((0.8192)*x109);
IkReal x154=(gconst11*gconst15*gconst8);
IkReal x155=((1.0)*gconst10*gconst5);
IkReal x156=(gconst4*x111);
IkReal x157=((0.4096)*x109);
IkReal x158=(x111*x126);
IkReal x159=(gconst5*gconst6*x146);
IkReal x160=((6.5536)*gconst1*x110);
IkReal x161=((6.5536)*gconst9*x110);
IkReal x162=((1.6384)*x119*x124);
IkReal x163=(x119*x157);
IkReal x164=((1.6384)*x112*x124);
IkReal x165=(gconst14*x116*x124);
IkReal x166=(x134*x157);
IkReal x167=(x112*x157);
IkReal x168=(gconst6*x116*x124);
IkReal x169=(x142*x157);
IkReal x170=(gconst9*x109*x110);
IkReal x171=(gconst12*x161);
IkReal x172=(gconst1*x109*x110);
IkReal x173=(x124*x125*x126);
IkReal x174=(x124*x126*x136);
IkReal x175=((0.8192)*x125*x151);
IkReal x176=((0.8192)*x136*x151);
IkReal x177=(x120*x124*x126);
IkReal x178=(x117*x124*x126);
IkReal x179=(x124*x126*x139);
IkReal x180=(x124*x126*x137);
IkReal x181=((0.8192)*x120*x151);
IkReal x182=((0.8192)*x117*x151);
IkReal x183=((0.8192)*x137*x151);
IkReal x184=((0.8192)*x139*x151);
IkReal x185=(x124*x126*x131);
IkReal x186=(x123*x124*x126);
IkReal x187=((0.8192)*x131*x151);
IkReal x188=((0.8192)*x123*x151);
IkReal x189=((3.2768)*gconst12*x109*x110);
IkReal x190=(x124*x171);
IkReal x191=(x132*x170);
IkReal x192=(gconst4*x124*x161);
IkReal x193=(gconst12*x124*x160);
IkReal x194=(x132*x172);
IkReal x195=(x143*x170);
IkReal x196=(gconst4*x124*x160);
IkReal x197=(x143*x172);
IkReal x198=(x168+x196);
IkReal x199=(x173+x174);
IkReal x200=(x187+x188);
IkReal x201=(x163+x191);
IkReal x202=(x169+x197);
IkReal x203=(x185+x186);
IkReal x204=(x162+x190);
IkReal x205=(x175+x176);
IkReal x206=(x184+x181+x182+x183);
IkReal x207=(x164+x165+x193+x192);
IkReal x208=(x166+x167+x195+x194);
IkReal x209=(x179+x178+x177+x180);
op[0]=((((-1.0)*x115*x154))+(((-1.0)*x201))+x205+((x141*x145))+((gconst11*gconst8*x118))+(((-1.0)*x118*x141)));
op[1]=(x199+(((-1.0)*x204)));
op[2]=((((-1.0)*x136*x155))+((x140*x145))+((gconst3*gconst8*x118))+(((-1.0)*x127*x154))+(((-1.0)*x137*x152))+((x114*x118))+((x128*x145))+((x136*x158))+(((-1.0)*gconst8*x115*x122))+(((-1.0)*x208))+((x119*x153))+(((-1.0)*x117*x152))+((x112*x147))+((x129*x141))+x206+(((3.2768)*gconst12*x170))+(((-1.6384)*x125*x151))+(((-1.0)*gconst15*x114*x115))+(((-1.6384)*x136*x151))+(((-1.0)*gconst11*x115*x121))+(((-1.0)*x118*x140))+(((-1.0)*x119*x150))+((x133*x141))+((x119*x135))+(((-1.0)*x111*x171))+((x125*x158)));
op[3]=((((-1.0)*x199))+(((-1.0)*x207))+x204+x209);
op[4]=(((x139*x158))+((x112*x135))+((x142*x147))+(((-1.0)*gconst14*x111*x116))+(((-1.0)*x137*x155))+((x120*x158))+(((-1.0)*x123*x152))+((x137*x158))+(((-1.0)*gconst7*x114*x115))+(((-1.0)*gconst5*x136*x146))+((x117*x158))+((x144*x145))+(((-1.0)*gconst12*x116*x151))+((x113*x119))+(((-1.0)*gconst8*x122*x127))+((x138*x141))+(((-1.6384)*x117*x151))+((x118*x148))+((x112*x153))+(((-1.0)*x201))+(((-1.0)*x202))+(((-1.0)*gconst11*x121*x127))+(((-1.0)*x117*x155))+((x112*x149))+(((-1.0)*gconst3*x115*x121))+((x129*x140))+x205+x200+(((3.2768)*gconst12*x172))+((x134*x135))+(((-1.0)*gconst0*x115*x122))+(((-1.0)*gconst13*x137*x146))+(((-1.0)*x112*x150))+((x134*x153))+((x128*x133))+(((-1.0)*gconst12*x111*x160))+(((-1.6384)*x139*x151))+(((-1.0)*gconst15*x114*x127))+((x128*x129))+((x133*x140))+((x130*x170))+(((-1.0)*x156*x161))+(((-1.6384)*x137*x151))+(((-1.0)*gconst13*x117*x146)));
op[5]=((((-1.0)*x198))+(((-1.0)*x209))+x207+x203);
op[6]=(((x142*x149))+((x123*x158))+((x112*x113))+((x142*x153))+(((-1.0)*gconst0*x122*x127))+(((-1.0)*x123*x155))+(((-1.0)*gconst13*x123*x146))+(((-1.6384)*x123*x151))+(((-1.0)*gconst5*x137*x146))+((x138*x140))+((x135*x142))+(((-1.0)*gconst4*x116*x151))+(((-1.0)*x208))+(((-1.0)*gconst7*x115*x148))+(((-1.0)*gconst7*x114*x127))+((x113*x134))+((x129*x144))+x206+(((-1.0)*gconst5*x117*x146))+((x128*x138))+((x133*x144))+(((-1.0)*gconst6*x111*x116))+(((-1.0)*gconst3*x121*x127))+((x130*x172))+(((-1.0)*x156*x160))+((x131*x158)));
op[7]=(x198+(((-1.0)*x203)));
op[8]=(((x113*x142))+(((-1.0)*gconst7*x127*x148))+((x138*x144))+(((-1.0)*x202))+x200+(((-1.0)*gconst5*x123*x146)));
polyroots8(op,zeror,numroots);
IkReal j6array[8], cj6array[8], sj6array[8], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[8]={true,true,true,true,true,true,true,true};
_nj6 = 8;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j5eval[2];
IkReal x210=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x210);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x210);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x210);
rxp2_2=0;
IkReal x211=(r21*sj6);
IkReal x212=(cj6*r20);
j5eval[0]=((r22*r22)+(((-2.0)*x211*x212))+(x211*x211)+(x212*x212));
j5eval[1]=((IKabs(r22))+(((3.125)*(IKabs(((((-0.32)*x211))+(((0.32)*x212))))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x213=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x213);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x213);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x213);
rxp2_2=0;
IkReal x214=pz*pz;
IkReal x215=(cj6*r20);
IkReal x216=(r21*sj6);
j5eval[0]=(((x214*(x216*x216)))+((x214*(x215*x215)))+(((-2.0)*x214*x215*x216))+((x214*(r22*r22))));
j5eval[1]=((IKabs((pz*r22)))+(IKabs((((pz*x215))+(((-1.0)*pz*x216))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x217=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x217);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x217);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x217);
rxp2_2=0;
IkReal x218=sj1*sj1;
IkReal x219=cj6*cj6;
IkReal x220=sj6*sj6;
IkReal x221=((1.0)*sj1);
IkReal x222=(x218*x220);
IkReal x223=(x218*x219);
IkReal x224=((2.0)*cj6*sj6*x218);
j0eval[0]=((IKabs(((((-1.0)*cj6*r11*x221))+(((-1.0)*r10*sj6*x221)))))+(IKabs(((((-1.0)*cj6*r01*x221))+(((-1.0)*r00*sj6*x221))))));
j0eval[1]=(((r10*r11*x224))+((x222*(r10*r10)))+((r00*r01*x224))+((x222*(r00*r00)))+((x223*(r01*r01)))+((x223*(r11*r11))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0, j5]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x225=((0.33)*sj1);
IkReal x226=(cj6*r21);
IkReal x227=((0.33)*cj1);
IkReal x228=((1.0)*pz);
IkReal x229=(r20*sj6);
IkReal x230=((((-1.0)*cj6*r01*x225))+(((-1.0)*r00*sj6*x225)));
IkReal x231=((((-1.0)*cj6*r11*x225))+(((-1.0)*r10*sj6*x225)));
CheckValue<IkReal> x234 = IKatan2WithCheck(IkReal(x230),IkReal(x231),IKFAST_ATAN2_MAGTHRESH);
if(!x234.valid){
continue;
}
IkReal x232=((1.0)*(x234.value));
if((((x230*x230)+(x231*x231))) < -0.00001)
continue;
CheckValue<IkReal> x235=IKPowWithIntegerCheck(IKabs(IKsqrt(((x230*x230)+(x231*x231)))),-1);
if(!x235.valid){
continue;
}
if( (((-1.0)*(x235.value)*(((((-1.0)*x227*x229))+(((-1.0)*x228*x229))+(((-1.0)*x226*x227))+(((-1.0)*x226*x228)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x235.value)*(((((-1.0)*x227*x229))+(((-1.0)*x228*x229))+(((-1.0)*x226*x227))+(((-1.0)*x226*x228)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x233=((-1.0)*(IKasin(((-1.0)*(x235.value)*(((((-1.0)*x227*x229))+(((-1.0)*x228*x229))+(((-1.0)*x226*x227))+(((-1.0)*x226*x228))))))));
j0array[0]=((((-1.0)*x233))+(((-1.0)*x232)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x232))+(((1.0)*x233)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j5eval[1];
IkReal x236=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x236);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x236);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x236);
rxp2_2=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x237=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x237);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x237);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x237);
rxp2_2=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x238=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x238);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x238);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x238);
rxp2_2=0;
j5eval[0]=(((cj6*r21))+((r20*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x240 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x240)==0){
continue;
}
IkReal x239=pow(x240,-0.5);
CheckValue<IkReal> x241 = IKatan2WithCheck(IkReal(r21),IkReal(r20),IKFAST_ATAN2_MAGTHRESH);
if(!x241.valid){
continue;
}
IkReal gconst32=((-1.0)*(x241.value));
IkReal gconst33=((-1.0)*r21*x239);
IkReal gconst34=(r20*x239);
CheckValue<IkReal> x242 = IKatan2WithCheck(IkReal(r21),IkReal(r20),IKFAST_ATAN2_MAGTHRESH);
if(!x242.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x242.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x243=(cj1*r22);
IkReal x244=(pz*r22);
IkReal x245=(r02*sj1);
IkReal x246=(r12*sj0);
IkReal x247=((33.0)*cj0*sj1);
CheckValue<IkReal> x248=IKPowWithIntegerCheck(((((32.0)*gconst34*r00))+(((-32.0)*gconst33*r01))),-1);
if(!x248.valid){
continue;
}
if( IKabs(((x248.value)*(((((-33.0)*cj0*r02*x245))+x247+(((-100.0)*r02*x244))+(((-33.0)*r02*x243))+(((-33.0)*x245*x246)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.03125)*cj0*x245))+(((-1.03125)*x243))+(((-1.03125)*sj1*x246))+(((-3.125)*x244)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x248.value)*(((((-33.0)*cj0*r02*x245))+x247+(((-100.0)*r02*x244))+(((-33.0)*r02*x243))+(((-33.0)*x245*x246))))))+IKsqr(((((-1.03125)*cj0*x245))+(((-1.03125)*x243))+(((-1.03125)*sj1*x246))+(((-3.125)*x244))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x248.value)*(((((-33.0)*cj0*r02*x245))+x247+(((-100.0)*r02*x244))+(((-33.0)*r02*x243))+(((-33.0)*x245*x246))))), ((((-1.03125)*cj0*x245))+(((-1.03125)*x243))+(((-1.03125)*sj1*x246))+(((-3.125)*x244))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x249=IKsin(j5);
IkReal x250=IKcos(j5);
IkReal x251=(gconst34*r20);
IkReal x252=(gconst33*r21);
IkReal x253=((0.33)*cj1);
IkReal x254=((0.64)*pz);
IkReal x255=((1.0)*pz);
IkReal x256=(gconst34*r10);
IkReal x257=(gconst33*r01);
IkReal x258=(gconst34*r00);
IkReal x259=(gconst33*r11);
IkReal x260=((0.32)*x249);
IkReal x261=((0.33)*sj0*sj1);
IkReal x262=(r22*x250);
IkReal x263=((0.33)*cj0*sj1);
IkReal x264=((0.32)*x250);
evalcond[0]=((((-1.0)*r22*x253))+(((-1.0)*r22*x255))+(((-1.0)*r12*x261))+(((-1.0)*r02*x263))+(((-1.0)*x264)));
evalcond[1]=(((x258*x260))+(((-1.0)*r02*x264))+(((-1.0)*x263))+(((-1.0)*x257*x260)));
evalcond[2]=((((-1.0)*r12*x264))+(((-1.0)*x259*x260))+((x256*x260))+(((-1.0)*x261)));
evalcond[3]=((((-0.32)*x262))+(((-1.0)*x252*x260))+((x251*x260))+(((-1.0)*x255))+(((-1.0)*x253)));
evalcond[4]=((0.0065)+((x249*x251*x254))+(((-1.0)*pz*x255))+(((-1.0)*x249*x252*x254))+(((-1.0)*x254*x262)));
evalcond[5]=(((x259*x261))+(((-1.0)*x258*x263))+(((-1.0)*x251*x253))+(((-1.0)*x251*x255))+((pz*x252))+x260+((x257*x263))+((x252*x253))+(((-1.0)*x256*x261)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x827 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x827)==0){
continue;
}
IkReal x826=pow(x827,-0.5);
CheckValue<IkReal> x828 = IKatan2WithCheck(IkReal(r21),IkReal(r20),IKFAST_ATAN2_MAGTHRESH);
if(!x828.valid){
continue;
}
IkReal gconst35=((3.14159265358979)+(((-1.0)*(x828.value))));
IkReal gconst36=((1.0)*r21*x826);
IkReal gconst37=((-1.0)*r20*x826);
CheckValue<IkReal> x829 = IKatan2WithCheck(IkReal(r21),IkReal(r20),IKFAST_ATAN2_MAGTHRESH);
if(!x829.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x829.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x830=(cj1*r22);
IkReal x831=(pz*r22);
IkReal x832=(r02*sj1);
IkReal x833=(r12*sj0);
IkReal x834=((33.0)*cj0*sj1);
CheckValue<IkReal> x835=IKPowWithIntegerCheck(((((-32.0)*gconst36*r01))+(((32.0)*gconst37*r00))),-1);
if(!x835.valid){
continue;
}
if( IKabs(((x835.value)*(((((-33.0)*r02*x830))+(((-33.0)*cj0*r02*x832))+(((-100.0)*r02*x831))+(((-33.0)*x832*x833))+x834)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.03125)*sj1*x833))+(((-1.03125)*x830))+(((-3.125)*x831))+(((-1.03125)*cj0*x832)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x835.value)*(((((-33.0)*r02*x830))+(((-33.0)*cj0*r02*x832))+(((-100.0)*r02*x831))+(((-33.0)*x832*x833))+x834))))+IKsqr(((((-1.03125)*sj1*x833))+(((-1.03125)*x830))+(((-3.125)*x831))+(((-1.03125)*cj0*x832))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x835.value)*(((((-33.0)*r02*x830))+(((-33.0)*cj0*r02*x832))+(((-100.0)*r02*x831))+(((-33.0)*x832*x833))+x834))), ((((-1.03125)*sj1*x833))+(((-1.03125)*x830))+(((-3.125)*x831))+(((-1.03125)*cj0*x832))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x836=IKcos(j5);
IkReal x837=IKsin(j5);
IkReal x838=(gconst36*r21);
IkReal x839=(gconst37*r10);
IkReal x840=((0.33)*cj1);
IkReal x841=(gconst36*r01);
IkReal x842=((0.64)*pz);
IkReal x843=((1.0)*pz);
IkReal x844=(gconst37*r20);
IkReal x845=(gconst37*r00);
IkReal x846=(gconst36*r11);
IkReal x847=((0.32)*x837);
IkReal x848=((0.33)*sj0*sj1);
IkReal x849=((0.33)*cj0*sj1);
IkReal x850=(r22*x836);
IkReal x851=((0.32)*x836);
evalcond[0]=((((-1.0)*r02*x849))+(((-1.0)*x851))+(((-1.0)*r22*x843))+(((-1.0)*r22*x840))+(((-1.0)*r12*x848)));
evalcond[1]=((((-1.0)*x841*x847))+(((-1.0)*r02*x851))+(((-1.0)*x849))+((x845*x847)));
evalcond[2]=((((-1.0)*r12*x851))+((x839*x847))+(((-1.0)*x846*x847))+(((-1.0)*x848)));
evalcond[3]=((((-0.32)*x850))+(((-1.0)*x843))+(((-1.0)*x840))+(((-1.0)*x838*x847))+((x844*x847)));
evalcond[4]=((0.0065)+(((-1.0)*x842*x850))+(((-1.0)*pz*x843))+((x837*x842*x844))+(((-1.0)*x837*x838*x842)));
evalcond[5]=(((x838*x840))+((x846*x848))+(((-1.0)*x840*x844))+((pz*x838))+(((-1.0)*x843*x844))+(((-1.0)*x839*x848))+(((-1.0)*x845*x849))+x847+((x841*x849)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x854 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x854)==0){
continue;
}
IkReal x852=pow(x854,-0.5);
IkReal x853=((-1.0)*x852);
CheckValue<IkReal> x855 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x855.valid){
continue;
}
IkReal gconst38=((-1.0)*(x855.value));
IkReal gconst39=(r10*x853);
IkReal gconst40=(r11*x853);
CheckValue<IkReal> x856 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x856.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j6+(x856.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x857=(cj1*r22);
IkReal x858=(pz*r22);
IkReal x859=(r02*sj1);
IkReal x860=(r12*sj0);
IkReal x861=((33.0)*cj0*sj1);
CheckValue<IkReal> x862=IKPowWithIntegerCheck(((((32.0)*gconst40*r00))+(((-32.0)*gconst39*r01))),-1);
if(!x862.valid){
continue;
}
if( IKabs(((x862.value)*(((((-100.0)*r02*x858))+(((-33.0)*x859*x860))+(((-33.0)*r02*x857))+(((-33.0)*cj0*r02*x859))+x861)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.03125)*x857))+(((-1.03125)*cj0*x859))+(((-3.125)*x858))+(((-1.03125)*sj1*x860)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x862.value)*(((((-100.0)*r02*x858))+(((-33.0)*x859*x860))+(((-33.0)*r02*x857))+(((-33.0)*cj0*r02*x859))+x861))))+IKsqr(((((-1.03125)*x857))+(((-1.03125)*cj0*x859))+(((-3.125)*x858))+(((-1.03125)*sj1*x860))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x862.value)*(((((-100.0)*r02*x858))+(((-33.0)*x859*x860))+(((-33.0)*r02*x857))+(((-33.0)*cj0*r02*x859))+x861))), ((((-1.03125)*x857))+(((-1.03125)*cj0*x859))+(((-3.125)*x858))+(((-1.03125)*sj1*x860))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x863=IKsin(j5);
IkReal x864=IKcos(j5);
IkReal x865=(gconst40*r10);
IkReal x866=((0.33)*cj1);
IkReal x867=(gconst40*r20);
IkReal x868=((1.0)*pz);
IkReal x869=(gconst40*r00);
IkReal x870=((0.33)*sj0*sj1);
IkReal x871=(gconst39*pz*r21);
IkReal x872=((0.64)*x863);
IkReal x873=((0.32)*x863);
IkReal x874=(r22*x864);
IkReal x875=((0.33)*cj0*sj1);
IkReal x876=((0.32)*x864);
IkReal x877=(gconst39*x873);
evalcond[0]=((((-1.0)*r12*x870))+(((-1.0)*r02*x875))+(((-1.0)*r22*x868))+(((-1.0)*r22*x866))+(((-1.0)*x876)));
evalcond[1]=((((-1.0)*r01*x877))+(((-1.0)*r02*x876))+((x869*x873))+(((-1.0)*x875)));
evalcond[2]=((((-1.0)*r12*x876))+((x865*x873))+(((-1.0)*r11*x877))+(((-1.0)*x870)));
evalcond[3]=((((-1.0)*x866))+(((-1.0)*x868))+((x867*x873))+(((-0.32)*x874))+(((-1.0)*r21*x877)));
evalcond[4]=((0.0065)+(((-1.0)*x871*x872))+(((-1.0)*pz*x868))+((pz*x867*x872))+(((-0.64)*pz*x874)));
evalcond[5]=(((gconst39*r21*x866))+((gconst39*r11*x870))+(((-1.0)*x866*x867))+(((-1.0)*x869*x875))+((gconst39*r01*x875))+x871+x873+(((-1.0)*x867*x868))+(((-1.0)*x865*x870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x880 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x880)==0){
continue;
}
IkReal x878=pow(x880,-0.5);
IkReal x879=((1.0)*x878);
CheckValue<IkReal> x881 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x881.valid){
continue;
}
IkReal gconst41=((3.14159265358979)+(((-1.0)*(x881.value))));
IkReal gconst42=(r10*x879);
IkReal gconst43=(r11*x879);
CheckValue<IkReal> x882 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x882.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j6+(x882.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x883=(cj1*r22);
IkReal x884=(pz*r22);
IkReal x885=(r02*sj1);
IkReal x886=(r12*sj0);
IkReal x887=((33.0)*cj0*sj1);
CheckValue<IkReal> x888=IKPowWithIntegerCheck(((((-32.0)*gconst42*r01))+(((32.0)*gconst43*r00))),-1);
if(!x888.valid){
continue;
}
if( IKabs(((x888.value)*(((((-100.0)*r02*x884))+(((-33.0)*x885*x886))+(((-33.0)*cj0*r02*x885))+(((-33.0)*r02*x883))+x887)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.03125)*cj0*x885))+(((-1.03125)*sj1*x886))+(((-3.125)*x884))+(((-1.03125)*x883)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x888.value)*(((((-100.0)*r02*x884))+(((-33.0)*x885*x886))+(((-33.0)*cj0*r02*x885))+(((-33.0)*r02*x883))+x887))))+IKsqr(((((-1.03125)*cj0*x885))+(((-1.03125)*sj1*x886))+(((-3.125)*x884))+(((-1.03125)*x883))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x888.value)*(((((-100.0)*r02*x884))+(((-33.0)*x885*x886))+(((-33.0)*cj0*r02*x885))+(((-33.0)*r02*x883))+x887))), ((((-1.03125)*cj0*x885))+(((-1.03125)*sj1*x886))+(((-3.125)*x884))+(((-1.03125)*x883))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x889=IKsin(j5);
IkReal x890=IKcos(j5);
IkReal x891=((0.33)*sj1);
IkReal x892=(gconst43*r00);
IkReal x893=((0.33)*cj1);
IkReal x894=((0.64)*pz);
IkReal x895=((1.0)*pz);
IkReal x896=(gconst42*r21);
IkReal x897=(gconst43*r20);
IkReal x898=(gconst43*x889);
IkReal x899=(r22*x890);
IkReal x900=((0.32)*x889);
IkReal x901=((0.32)*x890);
IkReal x902=(gconst42*x900);
evalcond[0]=((((-1.0)*x901))+(((-1.0)*cj0*r02*x891))+(((-1.0)*r22*x895))+(((-1.0)*r22*x893))+(((-1.0)*r12*sj0*x891)));
evalcond[1]=((((-1.0)*cj0*x891))+((x892*x900))+(((-1.0)*r01*x902))+(((-1.0)*r02*x901)));
evalcond[2]=((((0.32)*r10*x898))+(((-1.0)*sj0*x891))+(((-1.0)*r12*x901))+(((-1.0)*r11*x902)));
evalcond[3]=((((-1.0)*x896*x900))+(((-0.32)*x899))+(((-1.0)*x895))+(((-1.0)*x893))+((x897*x900)));
evalcond[4]=((0.0065)+((x889*x894*x897))+(((-1.0)*pz*x895))+(((-1.0)*x894*x899))+(((-1.0)*x889*x894*x896)));
evalcond[5]=(((gconst42*r11*sj0*x891))+((pz*x896))+(((-1.0)*x895*x897))+((cj0*gconst42*r01*x891))+(((-1.0)*cj0*x891*x892))+((x893*x896))+(((-1.0)*gconst43*r10*sj0*x891))+(((-1.0)*x893*x897))+x900);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x905 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x905)==0){
continue;
}
IkReal x903=pow(x905,-0.5);
IkReal x904=((-1.0)*x903);
CheckValue<IkReal> x906 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x906.valid){
continue;
}
IkReal gconst44=((-1.0)*(x906.value));
IkReal gconst45=(r00*x904);
IkReal gconst46=(r01*x904);
CheckValue<IkReal> x907 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x907.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x907.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x908=(cj1*r22);
IkReal x909=((33.0)*r12);
IkReal x910=(pz*r22);
IkReal x911=(cj0*r02*sj1);
IkReal x912=((33.0)*sj0*sj1);
CheckValue<IkReal> x913=IKPowWithIntegerCheck(((((-32.0)*gconst45*r11))+(((32.0)*gconst46*r10))),-1);
if(!x913.valid){
continue;
}
if( IKabs(((x913.value)*(((((-1.0)*x908*x909))+(((-1.0)*r12*sj0*sj1*x909))+(((-100.0)*r12*x910))+x912+(((-1.0)*x909*x911)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-3.125)*x910))+(((-1.03125)*r12*sj0*sj1))+(((-1.03125)*x908))+(((-1.03125)*x911)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x913.value)*(((((-1.0)*x908*x909))+(((-1.0)*r12*sj0*sj1*x909))+(((-100.0)*r12*x910))+x912+(((-1.0)*x909*x911))))))+IKsqr(((((-3.125)*x910))+(((-1.03125)*r12*sj0*sj1))+(((-1.03125)*x908))+(((-1.03125)*x911))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x913.value)*(((((-1.0)*x908*x909))+(((-1.0)*r12*sj0*sj1*x909))+(((-100.0)*r12*x910))+x912+(((-1.0)*x909*x911))))), ((((-3.125)*x910))+(((-1.03125)*r12*sj0*sj1))+(((-1.03125)*x908))+(((-1.03125)*x911))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x914=IKsin(j5);
IkReal x915=IKcos(j5);
IkReal x916=((0.33)*sj1);
IkReal x917=(gconst46*r00);
IkReal x918=((0.33)*cj1);
IkReal x919=((0.64)*pz);
IkReal x920=((1.0)*pz);
IkReal x921=(gconst46*r20);
IkReal x922=(gconst45*pz*r21);
IkReal x923=(r22*x915);
IkReal x924=((0.32)*x914);
IkReal x925=((0.32)*x915);
IkReal x926=(gconst45*x924);
IkReal x927=(gconst46*x924);
evalcond[0]=((((-1.0)*x925))+(((-1.0)*r22*x918))+(((-1.0)*r22*x920))+(((-1.0)*cj0*r02*x916))+(((-1.0)*r12*sj0*x916)));
evalcond[1]=((((-1.0)*cj0*x916))+(((-1.0)*r02*x925))+((x917*x924))+(((-1.0)*r01*x926)));
evalcond[2]=((((-1.0)*sj0*x916))+(((-1.0)*r11*x926))+(((-1.0)*r12*x925))+((r10*x927)));
evalcond[3]=((((-1.0)*x920))+(((-1.0)*r21*x926))+(((-1.0)*x918))+((x921*x924))+(((-0.32)*x923)));
evalcond[4]=((0.0065)+(((-1.0)*gconst45*r21*x914*x919))+(((-1.0)*pz*x920))+(((-1.0)*x919*x923))+((x914*x919*x921)));
evalcond[5]=((((-1.0)*gconst46*r10*sj0*x916))+((gconst45*r11*sj0*x916))+(((-1.0)*x920*x921))+((gconst45*r21*x918))+(((-1.0)*x918*x921))+(((-1.0)*cj0*x916*x917))+((cj0*gconst45*r01*x916))+x924+x922);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x930 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x930)==0){
continue;
}
IkReal x928=pow(x930,-0.5);
IkReal x929=((1.0)*x928);
CheckValue<IkReal> x931 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x931.valid){
continue;
}
IkReal gconst47=((3.14159265358979)+(((-1.0)*(x931.value))));
IkReal gconst48=(r00*x929);
IkReal gconst49=(r01*x929);
CheckValue<IkReal> x932 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x932.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x932.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x933=(cj1*r22);
IkReal x934=((33.0)*r12);
IkReal x935=(pz*r22);
IkReal x936=(cj0*r02*sj1);
IkReal x937=((33.0)*sj0*sj1);
CheckValue<IkReal> x938=IKPowWithIntegerCheck(((((32.0)*gconst49*r10))+(((-32.0)*gconst48*r11))),-1);
if(!x938.valid){
continue;
}
if( IKabs(((x938.value)*(((((-1.0)*r12*sj0*sj1*x934))+(((-1.0)*x934*x936))+(((-100.0)*r12*x935))+(((-1.0)*x933*x934))+x937)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.03125)*x933))+(((-1.03125)*x936))+(((-3.125)*x935))+(((-1.03125)*r12*sj0*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x938.value)*(((((-1.0)*r12*sj0*sj1*x934))+(((-1.0)*x934*x936))+(((-100.0)*r12*x935))+(((-1.0)*x933*x934))+x937))))+IKsqr(((((-1.03125)*x933))+(((-1.03125)*x936))+(((-3.125)*x935))+(((-1.03125)*r12*sj0*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x938.value)*(((((-1.0)*r12*sj0*sj1*x934))+(((-1.0)*x934*x936))+(((-100.0)*r12*x935))+(((-1.0)*x933*x934))+x937))), ((((-1.03125)*x933))+(((-1.03125)*x936))+(((-3.125)*x935))+(((-1.03125)*r12*sj0*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x939=IKsin(j5);
IkReal x940=IKcos(j5);
IkReal x941=((0.33)*cj1);
IkReal x942=((1.0)*pz);
IkReal x943=(gconst49*r20);
IkReal x944=(gconst48*r01);
IkReal x945=(gconst49*r00);
IkReal x946=(gconst48*r21);
IkReal x947=(gconst48*r11);
IkReal x948=(gconst49*r10);
IkReal x949=(pz*x946);
IkReal x950=((0.33)*sj0*sj1);
IkReal x951=((0.64)*x939);
IkReal x952=((0.33)*cj0*sj1);
IkReal x953=(r22*x940);
IkReal x954=((0.32)*x939);
IkReal x955=((0.32)*x940);
evalcond[0]=((((-1.0)*r12*x950))+(((-1.0)*r22*x942))+(((-1.0)*r22*x941))+(((-1.0)*x955))+(((-1.0)*r02*x952)));
evalcond[1]=((((-1.0)*x944*x954))+((x945*x954))+(((-1.0)*x952))+(((-1.0)*r02*x955)));
evalcond[2]=(((x948*x954))+(((-1.0)*x947*x954))+(((-1.0)*r12*x955))+(((-1.0)*x950)));
evalcond[3]=((((-1.0)*x942))+(((-1.0)*x941))+((x943*x954))+(((-1.0)*x946*x954))+(((-0.32)*x953)));
evalcond[4]=((0.0065)+(((-1.0)*pz*x942))+(((-0.64)*pz*x953))+(((-1.0)*x949*x951))+((pz*x943*x951)));
evalcond[5]=(((x944*x952))+(((-1.0)*x942*x943))+((x941*x946))+(((-1.0)*x941*x943))+((x947*x950))+(((-1.0)*x945*x952))+x954+x949+(((-1.0)*x948*x950)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r01))+(IKabs(r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=(pz*r10);
rxp0_1=0;
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=((-1.0)*pz*r02);
rxp2_2=0;
r00=0;
r01=0;
r12=0;
r22=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=(pz*r10);
rxp0_1=0;
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=((-1.0)*pz*r02);
rxp2_2=0;
r00=0;
r01=0;
r12=0;
r22=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=(pz*r10);
rxp0_1=0;
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=((-1.0)*pz*r02);
rxp2_2=0;
r00=0;
r01=0;
r12=0;
r22=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
j5eval[1]=r02;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x956=IKPowWithIntegerCheck(((((-32.0)*r11*sj6))+(((32.0)*cj6*r10))),-1);
if(!x956.valid){
continue;
}
CheckValue<IkReal> x957=IKPowWithIntegerCheck(r02,-1);
if(!x957.valid){
continue;
}
if( IKabs(((33.0)*sj0*sj1*(x956.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.03125)*cj0*sj1*(x957.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((33.0)*sj0*sj1*(x956.value)))+IKsqr(((-1.03125)*cj0*sj1*(x957.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((33.0)*sj0*sj1*(x956.value)), ((-1.03125)*cj0*sj1*(x957.value)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x958=IKcos(j5);
IkReal x959=IKsin(j5);
IkReal x960=((0.64)*pz);
IkReal x961=((1.0)*pz);
IkReal x962=(cj6*r20);
IkReal x963=((0.33)*sj1);
IkReal x964=(cj6*r10);
IkReal x965=(r21*sj6);
IkReal x966=((0.33)*cj1);
IkReal x967=(sj6*x959);
IkReal x968=((0.32)*x959);
IkReal x969=((0.32)*x958);
evalcond[0]=((((-1.0)*cj0*r02*x963))+(((-1.0)*x969)));
evalcond[1]=((((-1.0)*cj0*x963))+(((-1.0)*r02*x969)));
evalcond[2]=((((-1.0)*sj0*x963))+((x964*x968))+(((-0.32)*r11*x967)));
evalcond[3]=((((-1.0)*x965*x968))+((x962*x968))+(((-1.0)*x966))+(((-1.0)*x961)));
evalcond[4]=((0.0065)+(((-1.0)*pz*x961))+(((-1.0)*x959*x960*x965))+((x959*x960*x962)));
evalcond[5]=((((-1.0)*x962*x966))+(((-1.0)*x961*x962))+(((-1.0)*sj0*x963*x964))+((pz*x965))+((x965*x966))+((r11*sj0*sj6*x963))+x968);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x970=IKPowWithIntegerCheck(((((-0.32)*r21*sj6))+(((0.32)*cj6*r20))),-1);
if(!x970.valid){
continue;
}
if( IKabs(((x970.value)*((pz+(((0.33)*cj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.03125)*cj0*r02*sj1)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x970.value)*((pz+(((0.33)*cj1))))))+IKsqr(((-1.03125)*cj0*r02*sj1))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x970.value)*((pz+(((0.33)*cj1))))), ((-1.03125)*cj0*r02*sj1));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x971=IKcos(j5);
IkReal x972=IKsin(j5);
IkReal x973=((0.64)*pz);
IkReal x974=((1.0)*pz);
IkReal x975=(cj6*r20);
IkReal x976=((0.33)*sj1);
IkReal x977=(cj6*r10);
IkReal x978=(r21*sj6);
IkReal x979=((0.33)*cj1);
IkReal x980=(sj6*x972);
IkReal x981=((0.32)*x972);
IkReal x982=((0.32)*x971);
evalcond[0]=((((-1.0)*x982))+(((-1.0)*cj0*r02*x976)));
evalcond[1]=((((-1.0)*cj0*x976))+(((-1.0)*r02*x982)));
evalcond[2]=(((x977*x981))+(((-1.0)*sj0*x976))+(((-0.32)*r11*x980)));
evalcond[3]=(((x975*x981))+(((-1.0)*x978*x981))+(((-1.0)*x974))+(((-1.0)*x979)));
evalcond[4]=((0.0065)+((x972*x973*x975))+(((-1.0)*x972*x973*x978))+(((-1.0)*pz*x974)));
evalcond[5]=(((x978*x979))+(((-1.0)*x974*x975))+((r11*sj0*sj6*x976))+((pz*x978))+(((-1.0)*sj0*x976*x977))+x981+(((-1.0)*x975*x979)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x983=IKPowWithIntegerCheck(((((-32.0)*r11*sj6))+(((32.0)*cj6*r10))),-1);
if(!x983.valid){
continue;
}
if( IKabs(((33.0)*sj0*sj1*(x983.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.03125)*cj0*r02*sj1)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((33.0)*sj0*sj1*(x983.value)))+IKsqr(((-1.03125)*cj0*r02*sj1))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((33.0)*sj0*sj1*(x983.value)), ((-1.03125)*cj0*r02*sj1));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x984=IKcos(j5);
IkReal x985=IKsin(j5);
IkReal x986=((0.64)*pz);
IkReal x987=((1.0)*pz);
IkReal x988=(cj6*r20);
IkReal x989=((0.33)*sj1);
IkReal x990=(cj6*r10);
IkReal x991=(r21*sj6);
IkReal x992=((0.33)*cj1);
IkReal x993=(sj6*x985);
IkReal x994=((0.32)*x985);
IkReal x995=((0.32)*x984);
evalcond[0]=((((-1.0)*x995))+(((-1.0)*cj0*r02*x989)));
evalcond[1]=((((-1.0)*cj0*x989))+(((-1.0)*r02*x995)));
evalcond[2]=(((x990*x994))+(((-1.0)*sj0*x989))+(((-0.32)*r11*x993)));
evalcond[3]=((((-1.0)*x987))+((x988*x994))+(((-1.0)*x991*x994))+(((-1.0)*x992)));
evalcond[4]=((0.0065)+(((-1.0)*pz*x987))+((x985*x986*x988))+(((-1.0)*x985*x986*x991)));
evalcond[5]=(((x991*x992))+((pz*x991))+((r11*sj0*sj6*x989))+(((-1.0)*x987*x988))+x994+(((-1.0)*x988*x992))+(((-1.0)*sj0*x989*x990)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x996=(r20*sj6);
IkReal x997=((33.0)*sj1);
IkReal x998=(cj6*r21);
IkReal x999=((10.56)*sj1*sj6);
IkReal x1000=((10.56)*cj6*sj1);
CheckValue<IkReal> x1001=IKPowWithIntegerCheck(((((32.0)*x998))+(((32.0)*x996))),-1);
if(!x1001.valid){
continue;
}
CheckValue<IkReal> x1002=IKPowWithIntegerCheck(((((10.24)*x996))+(((10.24)*x998))),-1);
if(!x1002.valid){
continue;
}
if( IKabs(((x1001.value)*(((((-1.0)*cj0*r12*x997))+((r02*sj0*x997)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1002.value)*(((((-1.0)*cj0*r10*x1000))+((cj0*r11*x999))+((r00*sj0*x1000))+(((-1.0)*r01*sj0*x999)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1001.value)*(((((-1.0)*cj0*r12*x997))+((r02*sj0*x997))))))+IKsqr(((x1002.value)*(((((-1.0)*cj0*r10*x1000))+((cj0*r11*x999))+((r00*sj0*x1000))+(((-1.0)*r01*sj0*x999))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1001.value)*(((((-1.0)*cj0*r12*x997))+((r02*sj0*x997))))), ((x1002.value)*(((((-1.0)*cj0*r10*x1000))+((cj0*r11*x999))+((r00*sj0*x1000))+(((-1.0)*r01*sj0*x999))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1003=IKcos(j5);
IkReal x1004=IKsin(j5);
IkReal x1005=((0.33)*cj1);
IkReal x1006=(r21*sj6);
IkReal x1007=(cj6*r00);
IkReal x1008=((1.0)*pz);
IkReal x1009=(cj6*r20);
IkReal x1010=(r11*sj6);
IkReal x1011=((0.64)*pz);
IkReal x1012=(r01*sj6);
IkReal x1013=(cj6*r10);
IkReal x1014=((0.33)*sj0*sj1);
IkReal x1015=((0.32)*x1004);
IkReal x1016=(r22*x1003);
IkReal x1017=((0.33)*cj0*sj1);
IkReal x1018=((0.32)*x1003);
evalcond[0]=((((-1.0)*x1018))+(((-1.0)*r02*x1017))+(((-1.0)*r12*x1014))+(((-1.0)*r22*x1008))+(((-1.0)*r22*x1005)));
evalcond[1]=((((-1.0)*x1012*x1015))+(((-1.0)*x1017))+(((-1.0)*r02*x1018))+((x1007*x1015)));
evalcond[2]=((((-1.0)*x1010*x1015))+(((-1.0)*x1014))+((x1013*x1015))+(((-1.0)*r12*x1018)));
evalcond[3]=(((x1009*x1015))+(((-1.0)*x1008))+(((-1.0)*x1005))+(((-1.0)*x1006*x1015))+(((-0.32)*x1016)));
evalcond[4]=((0.0065)+(((-1.0)*x1011*x1016))+(((-1.0)*pz*x1008))+(((-1.0)*x1004*x1006*x1011))+((x1004*x1009*x1011)));
evalcond[5]=(x1015+(((-1.0)*x1008*x1009))+((x1012*x1017))+(((-1.0)*x1005*x1009))+((pz*x1006))+((x1005*x1006))+(((-1.0)*x1013*x1014))+(((-1.0)*x1007*x1017))+((x1010*x1014)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1019=(cj1*r22);
IkReal x1020=((33.0)*r12);
IkReal x1021=(pz*r22);
IkReal x1022=(cj0*r02*sj1);
IkReal x1023=((33.0)*sj0*sj1);
CheckValue<IkReal> x1024=IKPowWithIntegerCheck(((((-32.0)*r11*sj6))+(((32.0)*cj6*r10))),-1);
if(!x1024.valid){
continue;
}
if( IKabs(((x1024.value)*(((((-1.0)*r12*sj0*sj1*x1020))+x1023+(((-100.0)*r12*x1021))+(((-1.0)*x1019*x1020))+(((-1.0)*x1020*x1022)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.03125)*x1022))+(((-1.03125)*x1019))+(((-3.125)*x1021))+(((-1.03125)*r12*sj0*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1024.value)*(((((-1.0)*r12*sj0*sj1*x1020))+x1023+(((-100.0)*r12*x1021))+(((-1.0)*x1019*x1020))+(((-1.0)*x1020*x1022))))))+IKsqr(((((-1.03125)*x1022))+(((-1.03125)*x1019))+(((-3.125)*x1021))+(((-1.03125)*r12*sj0*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1024.value)*(((((-1.0)*r12*sj0*sj1*x1020))+x1023+(((-100.0)*r12*x1021))+(((-1.0)*x1019*x1020))+(((-1.0)*x1020*x1022))))), ((((-1.03125)*x1022))+(((-1.03125)*x1019))+(((-3.125)*x1021))+(((-1.03125)*r12*sj0*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1025=IKcos(j5);
IkReal x1026=IKsin(j5);
IkReal x1027=((0.33)*cj1);
IkReal x1028=(r21*sj6);
IkReal x1029=(cj6*r00);
IkReal x1030=((1.0)*pz);
IkReal x1031=(cj6*r20);
IkReal x1032=(r11*sj6);
IkReal x1033=((0.64)*pz);
IkReal x1034=(r01*sj6);
IkReal x1035=(cj6*r10);
IkReal x1036=((0.33)*sj0*sj1);
IkReal x1037=((0.32)*x1026);
IkReal x1038=(r22*x1025);
IkReal x1039=((0.33)*cj0*sj1);
IkReal x1040=((0.32)*x1025);
evalcond[0]=((((-1.0)*r22*x1027))+(((-1.0)*r02*x1039))+(((-1.0)*r12*x1036))+(((-1.0)*r22*x1030))+(((-1.0)*x1040)));
evalcond[1]=((((-1.0)*r02*x1040))+(((-1.0)*x1039))+(((-1.0)*x1034*x1037))+((x1029*x1037)));
evalcond[2]=((((-1.0)*x1036))+(((-1.0)*x1032*x1037))+(((-1.0)*r12*x1040))+((x1035*x1037)));
evalcond[3]=(((x1031*x1037))+(((-1.0)*x1030))+(((-1.0)*x1028*x1037))+(((-1.0)*x1027))+(((-0.32)*x1038)));
evalcond[4]=((0.0065)+(((-1.0)*x1033*x1038))+(((-1.0)*pz*x1030))+(((-1.0)*x1026*x1028*x1033))+((x1026*x1031*x1033)));
evalcond[5]=((((-1.0)*x1027*x1031))+x1037+(((-1.0)*x1035*x1036))+(((-1.0)*x1029*x1039))+((x1034*x1039))+(((-1.0)*x1030*x1031))+((x1027*x1028))+((x1032*x1036))+((pz*x1028)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1041=(cj1*r22);
IkReal x1042=(pz*r22);
IkReal x1043=(r02*sj1);
IkReal x1044=(r12*sj0);
IkReal x1045=((33.0)*cj0*sj1);
CheckValue<IkReal> x1046=IKPowWithIntegerCheck(((((-32.0)*r01*sj6))+(((32.0)*cj6*r00))),-1);
if(!x1046.valid){
continue;
}
if( IKabs(((x1046.value)*((x1045+(((-33.0)*cj0*r02*x1043))+(((-100.0)*r02*x1042))+(((-33.0)*x1043*x1044))+(((-33.0)*r02*x1041)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-3.125)*x1042))+(((-1.03125)*sj1*x1044))+(((-1.03125)*x1041))+(((-1.03125)*cj0*x1043)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1046.value)*((x1045+(((-33.0)*cj0*r02*x1043))+(((-100.0)*r02*x1042))+(((-33.0)*x1043*x1044))+(((-33.0)*r02*x1041))))))+IKsqr(((((-3.125)*x1042))+(((-1.03125)*sj1*x1044))+(((-1.03125)*x1041))+(((-1.03125)*cj0*x1043))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1046.value)*((x1045+(((-33.0)*cj0*r02*x1043))+(((-100.0)*r02*x1042))+(((-33.0)*x1043*x1044))+(((-33.0)*r02*x1041))))), ((((-3.125)*x1042))+(((-1.03125)*sj1*x1044))+(((-1.03125)*x1041))+(((-1.03125)*cj0*x1043))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1047=IKcos(j5);
IkReal x1048=IKsin(j5);
IkReal x1049=((0.33)*cj1);
IkReal x1050=(r21*sj6);
IkReal x1051=(cj6*r00);
IkReal x1052=((1.0)*pz);
IkReal x1053=(cj6*r20);
IkReal x1054=(r11*sj6);
IkReal x1055=((0.64)*pz);
IkReal x1056=(r01*sj6);
IkReal x1057=(cj6*r10);
IkReal x1058=((0.33)*sj0*sj1);
IkReal x1059=((0.32)*x1048);
IkReal x1060=(r22*x1047);
IkReal x1061=((0.33)*cj0*sj1);
IkReal x1062=((0.32)*x1047);
evalcond[0]=((((-1.0)*r02*x1061))+(((-1.0)*r22*x1049))+(((-1.0)*r12*x1058))+(((-1.0)*r22*x1052))+(((-1.0)*x1062)));
evalcond[1]=((((-1.0)*r02*x1062))+((x1051*x1059))+(((-1.0)*x1056*x1059))+(((-1.0)*x1061)));
evalcond[2]=((((-1.0)*x1058))+((x1057*x1059))+(((-1.0)*r12*x1062))+(((-1.0)*x1054*x1059)));
evalcond[3]=((((-1.0)*x1052))+((x1053*x1059))+(((-1.0)*x1050*x1059))+(((-0.32)*x1060))+(((-1.0)*x1049)));
evalcond[4]=((0.0065)+(((-1.0)*x1048*x1050*x1055))+((x1048*x1053*x1055))+(((-1.0)*pz*x1052))+(((-1.0)*x1055*x1060)));
evalcond[5]=(((x1056*x1061))+(((-1.0)*x1052*x1053))+((x1054*x1058))+x1059+((pz*x1050))+((x1049*x1050))+(((-1.0)*x1057*x1058))+(((-1.0)*x1051*x1061))+(((-1.0)*x1049*x1053)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1063=pz*pz;
IkReal x1064=((0.64)*pz);
IkReal x1065=((((-1.0)*r21*sj6*x1064))+((cj6*r20*x1064)));
CheckValue<IkReal> x1068 = IKatan2WithCheck(IkReal(((-0.64)*pz*r22)),IkReal(x1065),IKFAST_ATAN2_MAGTHRESH);
if(!x1068.valid){
continue;
}
IkReal x1066=((1.0)*(x1068.value));
if((((((0.4096)*x1063*(r22*r22)))+(x1065*x1065))) < -0.00001)
continue;
CheckValue<IkReal> x1069=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.4096)*x1063*(r22*r22)))+(x1065*x1065)))),-1);
if(!x1069.valid){
continue;
}
if( (((x1069.value)*(((0.0065)+(((-1.0)*x1063)))))) < -1-IKFAST_SINCOS_THRESH || (((x1069.value)*(((0.0065)+(((-1.0)*x1063)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1067=IKasin(((x1069.value)*(((0.0065)+(((-1.0)*x1063))))));
j5array[0]=((((-1.0)*x1066))+(((-1.0)*x1067)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x1067+(((-1.0)*x1066)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1070=IKsin(j5);
IkReal x1071=((0.32)*x1070);
evalcond[0]=(((cj6*r20*x1071))+(((-0.32)*r22*(IKcos(j5))))+(((-1.0)*r21*sj6*x1071))+(((-1.0)*pz))+(((-0.33)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[3];
IkReal x1072=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1072);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1072);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1072);
rxp2_2=0;
IkReal x1073=((32.0)*cj5);
IkReal x1074=((32.0)*sj5*sj6);
IkReal x1075=((32.0)*cj6*sj5);
j0eval[0]=sj1;
j0eval[1]=IKsign(sj1);
j0eval[2]=((IKabs(((((-1.0)*r12*x1073))+(((-1.0)*r11*x1074))+((r10*x1075)))))+(IKabs(((((-1.0)*r01*x1074))+(((-1.0)*r02*x1073))+((r00*x1075))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1076=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1076);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1076);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1076);
rxp2_2=0;
IkReal x1077=cj1*cj1;
IkReal x1078=(r10*sj6);
IkReal x1079=(cj6*r11);
j0eval[0]=(((x1077*x1079))+((x1077*x1078))+(((-1.0)*x1078))+(((-1.0)*x1079)));
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1080=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1080);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1080);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1080);
rxp2_2=0;
j0eval[0]=r12;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x1086=IKPowWithIntegerCheck(sj1,-1);
if(!x1086.valid){
continue;
}
IkReal x1081=x1086.value;
IkReal x1082=((32.0)*cj5);
IkReal x1083=((0.0303030303030303)*x1081);
IkReal x1084=((32.0)*r01*sj5*sj6);
IkReal x1085=((32.0)*cj6*r00*sj5);
CheckValue<IkReal> x1087=IKPowWithIntegerCheck(r12,-1);
if(!x1087.valid){
continue;
}
if( IKabs((x1083*(x1087.value)*((((x1082*(r02*r02)))+(((-1.0)*r02*x1085))+(((-33.0)*cj1*r22))+(((-100.0)*pz*r22))+((r02*x1084))+(((-1.0)*x1082)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1083*((x1085+(((-1.0)*r02*x1082))+(((-1.0)*x1084)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1083*(x1087.value)*((((x1082*(r02*r02)))+(((-1.0)*r02*x1085))+(((-33.0)*cj1*r22))+(((-100.0)*pz*r22))+((r02*x1084))+(((-1.0)*x1082))))))+IKsqr((x1083*((x1085+(((-1.0)*r02*x1082))+(((-1.0)*x1084))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x1083*(x1087.value)*((((x1082*(r02*r02)))+(((-1.0)*r02*x1085))+(((-33.0)*cj1*r22))+(((-100.0)*pz*r22))+((r02*x1084))+(((-1.0)*x1082))))), (x1083*((x1085+(((-1.0)*r02*x1082))+(((-1.0)*x1084))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1088=IKcos(j0);
IkReal x1089=IKsin(j0);
IkReal x1090=((0.32)*sj5);
IkReal x1091=(cj6*r10);
IkReal x1092=(r01*sj6);
IkReal x1093=((0.33)*cj1);
IkReal x1094=(pz*sj6);
IkReal x1095=((1.0)*r20);
IkReal x1096=(cj6*pz);
IkReal x1097=(r11*sj6);
IkReal x1098=((0.32)*cj5);
IkReal x1099=(cj6*r00);
IkReal x1100=((0.33)*sj1*x1088);
IkReal x1101=((0.33)*sj1*x1089);
evalcond[0]=((((-1.0)*x1090*x1092))+(((-1.0)*r02*x1098))+(((-1.0)*x1100))+((x1090*x1099)));
evalcond[1]=((((-1.0)*x1090*x1097))+(((-1.0)*r12*x1098))+(((-1.0)*x1101))+((x1090*x1091)));
evalcond[2]=((((-1.0)*r12*x1101))+(((-1.0)*pz*r22))+(((-1.0)*x1098))+(((-1.0)*r02*x1100))+(((-1.0)*r22*x1093)));
evalcond[3]=((((-1.0)*r10*sj6*x1101))+(((-1.0)*cj6*r01*x1100))+(((-1.0)*x1094*x1095))+(((-1.0)*cj6*r11*x1101))+(((-1.0)*cj6*r21*x1093))+(((-1.0)*r21*x1096))+(((-1.0)*r00*sj6*x1100))+(((-1.0)*r20*sj6*x1093)));
evalcond[4]=((((-1.0)*x1091*x1101))+((x1092*x1100))+x1090+((x1097*x1101))+((r21*x1094))+(((-1.0)*cj6*r20*x1093))+(((-1.0)*x1095*x1096))+(((-1.0)*x1099*x1100))+((r21*sj6*x1093)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1102=cj1*cj1;
IkReal x1103=(cj6*sj5);
IkReal x1104=(cj5*r02);
IkReal x1105=(r01*sj5);
IkReal x1106=((33.0)*pz);
IkReal x1107=((10.56)*sj1);
IkReal x1108=((10.89)*cj1);
IkReal x1109=(sj6*x1107);
IkReal x1110=((10.89)*r10*sj6);
IkReal x1111=(r20*sj1*sj6);
IkReal x1112=((10.89)*cj6*r11);
IkReal x1113=(cj6*r21*sj1);
CheckValue<IkReal> x1114=IKPowWithIntegerCheck((((x1102*x1112))+((x1102*x1110))+(((-1.0)*x1112))+(((-1.0)*x1110))),-1);
if(!x1114.valid){
continue;
}
CheckValue<IkReal> x1115=IKPowWithIntegerCheck(sj1,-1);
if(!x1115.valid){
continue;
}
if( IKabs(((x1114.value)*((((x1108*x1113))+((x1108*x1111))+(((-1.0)*r00*x1105*x1107))+(((21.12)*cj6*r00*r01*sj1*x1103))+((x1103*x1109*(r00*r00)))+(((-1.0)*cj6*r01*x1104*x1107))+(((-1.0)*r00*x1104*x1109))+(((-1.0)*x1103*x1109*(r01*r01)))+((x1106*x1113))+((x1106*x1111)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0303030303030303)*(x1115.value)*(((((32.0)*r00*x1103))+(((-32.0)*x1104))+(((-32.0)*sj6*x1105)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1114.value)*((((x1108*x1113))+((x1108*x1111))+(((-1.0)*r00*x1105*x1107))+(((21.12)*cj6*r00*r01*sj1*x1103))+((x1103*x1109*(r00*r00)))+(((-1.0)*cj6*r01*x1104*x1107))+(((-1.0)*r00*x1104*x1109))+(((-1.0)*x1103*x1109*(r01*r01)))+((x1106*x1113))+((x1106*x1111))))))+IKsqr(((0.0303030303030303)*(x1115.value)*(((((32.0)*r00*x1103))+(((-32.0)*x1104))+(((-32.0)*sj6*x1105))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1114.value)*((((x1108*x1113))+((x1108*x1111))+(((-1.0)*r00*x1105*x1107))+(((21.12)*cj6*r00*r01*sj1*x1103))+((x1103*x1109*(r00*r00)))+(((-1.0)*cj6*r01*x1104*x1107))+(((-1.0)*r00*x1104*x1109))+(((-1.0)*x1103*x1109*(r01*r01)))+((x1106*x1113))+((x1106*x1111))))), ((0.0303030303030303)*(x1115.value)*(((((32.0)*r00*x1103))+(((-32.0)*x1104))+(((-32.0)*sj6*x1105))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1116=IKcos(j0);
IkReal x1117=IKsin(j0);
IkReal x1118=((0.32)*sj5);
IkReal x1119=(cj6*r10);
IkReal x1120=(r01*sj6);
IkReal x1121=((0.33)*cj1);
IkReal x1122=(pz*sj6);
IkReal x1123=((1.0)*r20);
IkReal x1124=(cj6*pz);
IkReal x1125=(r11*sj6);
IkReal x1126=((0.32)*cj5);
IkReal x1127=(cj6*r00);
IkReal x1128=((0.33)*sj1*x1116);
IkReal x1129=((0.33)*sj1*x1117);
evalcond[0]=((((-1.0)*x1128))+(((-1.0)*r02*x1126))+(((-1.0)*x1118*x1120))+((x1118*x1127)));
evalcond[1]=((((-1.0)*r12*x1126))+(((-1.0)*x1129))+(((-1.0)*x1118*x1125))+((x1118*x1119)));
evalcond[2]=((((-1.0)*r12*x1129))+(((-1.0)*pz*r22))+(((-1.0)*x1126))+(((-1.0)*r22*x1121))+(((-1.0)*r02*x1128)));
evalcond[3]=((((-1.0)*cj6*r21*x1121))+(((-1.0)*r00*sj6*x1128))+(((-1.0)*cj6*r11*x1129))+(((-1.0)*x1122*x1123))+(((-1.0)*cj6*r01*x1128))+(((-1.0)*r10*sj6*x1129))+(((-1.0)*r21*x1124))+(((-1.0)*r20*sj6*x1121)));
evalcond[4]=(x1118+((x1120*x1128))+((r21*sj6*x1121))+(((-1.0)*x1123*x1124))+(((-1.0)*cj6*r20*x1121))+(((-1.0)*x1127*x1128))+((x1125*x1129))+((r21*x1122))+(((-1.0)*x1119*x1129)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1130=((32.0)*cj5);
IkReal x1131=((32.0)*sj5*sj6);
IkReal x1132=((32.0)*cj6*sj5);
CheckValue<IkReal> x1133=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x1133.valid){
continue;
}
CheckValue<IkReal> x1134 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1131))+(((-1.0)*r12*x1130))+((r10*x1132)))),IkReal((((r00*x1132))+(((-1.0)*r02*x1130))+(((-1.0)*r01*x1131)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1134.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1133.value)))+(x1134.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1135=IKcos(j0);
IkReal x1136=IKsin(j0);
IkReal x1137=((0.32)*sj5);
IkReal x1138=(cj6*r10);
IkReal x1139=(r01*sj6);
IkReal x1140=((0.33)*cj1);
IkReal x1141=(pz*sj6);
IkReal x1142=((1.0)*r20);
IkReal x1143=(cj6*pz);
IkReal x1144=(r11*sj6);
IkReal x1145=((0.32)*cj5);
IkReal x1146=(cj6*r00);
IkReal x1147=((0.33)*sj1*x1135);
IkReal x1148=((0.33)*sj1*x1136);
evalcond[0]=(((x1137*x1146))+(((-1.0)*x1147))+(((-1.0)*r02*x1145))+(((-1.0)*x1137*x1139)));
evalcond[1]=((((-1.0)*x1137*x1144))+((x1137*x1138))+(((-1.0)*x1148))+(((-1.0)*r12*x1145)));
evalcond[2]=((((-1.0)*pz*r22))+(((-1.0)*x1145))+(((-1.0)*r02*x1147))+(((-1.0)*r12*x1148))+(((-1.0)*r22*x1140)));
evalcond[3]=((((-1.0)*x1141*x1142))+(((-1.0)*r10*sj6*x1148))+(((-1.0)*cj6*r21*x1140))+(((-1.0)*r21*x1143))+(((-1.0)*r00*sj6*x1147))+(((-1.0)*r20*sj6*x1140))+(((-1.0)*cj6*r11*x1148))+(((-1.0)*cj6*r01*x1147)));
evalcond[4]=(x1137+(((-1.0)*cj6*r20*x1140))+(((-1.0)*x1146*x1147))+((r21*sj6*x1140))+((x1139*x1147))+((r21*x1141))+((x1144*x1148))+(((-1.0)*x1142*x1143))+(((-1.0)*x1138*x1148)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1149=((((-0.32)*r21*sj6))+(((0.32)*cj6*r20)));
CheckValue<IkReal> x1152 = IKatan2WithCheck(IkReal(((-0.32)*r22)),IkReal(x1149),IKFAST_ATAN2_MAGTHRESH);
if(!x1152.valid){
continue;
}
IkReal x1150=((1.0)*(x1152.value));
if((((((0.1024)*(r22*r22)))+(x1149*x1149))) < -0.00001)
continue;
CheckValue<IkReal> x1153=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.1024)*(r22*r22)))+(x1149*x1149)))),-1);
if(!x1153.valid){
continue;
}
if( (((-1.0)*(x1153.value)*(((((-1.0)*pz))+(((-0.33)*cj1)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1153.value)*(((((-1.0)*pz))+(((-0.33)*cj1)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1151=((-1.0)*(IKasin(((-1.0)*(x1153.value)*(((((-1.0)*pz))+(((-0.33)*cj1))))))));
j5array[0]=((((-1.0)*x1150))+(((-1.0)*x1151)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1150))+(((1.0)*x1151)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1154=IKsin(j5);
IkReal x1155=((0.64)*pz*x1154);
evalcond[0]=((0.0065)+((cj6*r20*x1155))+(((-1.0)*(pz*pz)))+(((-0.64)*pz*r22*(IKcos(j5))))+(((-1.0)*r21*sj6*x1155)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[3];
IkReal x1156=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1156);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1156);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1156);
rxp2_2=0;
IkReal x1157=((32.0)*cj5);
IkReal x1158=((32.0)*sj5*sj6);
IkReal x1159=((32.0)*cj6*sj5);
j0eval[0]=sj1;
j0eval[1]=IKsign(sj1);
j0eval[2]=((IKabs((((r00*x1159))+(((-1.0)*r01*x1158))+(((-1.0)*r02*x1157)))))+(IKabs(((((-1.0)*r11*x1158))+(((-1.0)*r12*x1157))+((r10*x1159))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1160=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1160);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1160);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1160);
rxp2_2=0;
IkReal x1161=cj1*cj1;
IkReal x1162=(r10*sj6);
IkReal x1163=(cj6*r11);
j0eval[0]=((((-1.0)*x1162))+(((-1.0)*x1163))+((x1161*x1162))+((x1161*x1163)));
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1164=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1164);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1164);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1164);
rxp2_2=0;
j0eval[0]=r12;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x1170=IKPowWithIntegerCheck(sj1,-1);
if(!x1170.valid){
continue;
}
IkReal x1165=x1170.value;
IkReal x1166=((32.0)*cj5);
IkReal x1167=((0.0303030303030303)*x1165);
IkReal x1168=((32.0)*r01*sj5*sj6);
IkReal x1169=((32.0)*cj6*r00*sj5);
CheckValue<IkReal> x1171=IKPowWithIntegerCheck(r12,-1);
if(!x1171.valid){
continue;
}
if( IKabs((x1167*(x1171.value)*(((((-1.0)*r02*x1169))+((r02*x1168))+((x1166*(r02*r02)))+(((-33.0)*cj1*r22))+(((-100.0)*pz*r22))+(((-1.0)*x1166)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1167*((x1169+(((-1.0)*r02*x1166))+(((-1.0)*x1168)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1167*(x1171.value)*(((((-1.0)*r02*x1169))+((r02*x1168))+((x1166*(r02*r02)))+(((-33.0)*cj1*r22))+(((-100.0)*pz*r22))+(((-1.0)*x1166))))))+IKsqr((x1167*((x1169+(((-1.0)*r02*x1166))+(((-1.0)*x1168))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x1167*(x1171.value)*(((((-1.0)*r02*x1169))+((r02*x1168))+((x1166*(r02*r02)))+(((-33.0)*cj1*r22))+(((-100.0)*pz*r22))+(((-1.0)*x1166))))), (x1167*((x1169+(((-1.0)*r02*x1166))+(((-1.0)*x1168))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1172=IKcos(j0);
IkReal x1173=IKsin(j0);
IkReal x1174=((0.32)*sj5);
IkReal x1175=(cj6*r10);
IkReal x1176=(r01*sj6);
IkReal x1177=((0.33)*cj1);
IkReal x1178=(pz*sj6);
IkReal x1179=((1.0)*r20);
IkReal x1180=(cj6*pz);
IkReal x1181=(r11*sj6);
IkReal x1182=((0.32)*cj5);
IkReal x1183=(cj6*r00);
IkReal x1184=((0.33)*sj1*x1172);
IkReal x1185=((0.33)*sj1*x1173);
evalcond[0]=(((x1174*x1183))+(((-1.0)*x1184))+(((-1.0)*r02*x1182))+(((-1.0)*x1174*x1176)));
evalcond[1]=(((x1174*x1175))+(((-1.0)*x1185))+(((-1.0)*x1174*x1181))+(((-1.0)*r12*x1182)));
evalcond[2]=((((-1.0)*pz*r22))+(((-1.0)*x1182))+(((-1.0)*r22*x1177))+(((-1.0)*r12*x1185))+(((-1.0)*r02*x1184)));
evalcond[3]=((((-1.0)*cj6*r01*x1184))+(((-1.0)*r20*sj6*x1177))+(((-1.0)*r00*sj6*x1184))+(((-1.0)*cj6*r11*x1185))+(((-1.0)*x1178*x1179))+(((-1.0)*r10*sj6*x1185))+(((-1.0)*r21*x1180))+(((-1.0)*cj6*r21*x1177)));
evalcond[4]=((((-1.0)*x1175*x1185))+x1174+((r21*sj6*x1177))+((r21*x1178))+((x1176*x1184))+(((-1.0)*x1179*x1180))+(((-1.0)*cj6*r20*x1177))+((x1181*x1185))+(((-1.0)*x1183*x1184)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1186=cj1*cj1;
IkReal x1187=(cj6*sj5);
IkReal x1188=(cj5*r02);
IkReal x1189=(r01*sj5);
IkReal x1190=((33.0)*pz);
IkReal x1191=((10.56)*sj1);
IkReal x1192=((10.89)*cj1);
IkReal x1193=(sj6*x1191);
IkReal x1194=((10.89)*r10*sj6);
IkReal x1195=(r20*sj1*sj6);
IkReal x1196=((10.89)*cj6*r11);
IkReal x1197=(cj6*r21*sj1);
CheckValue<IkReal> x1198=IKPowWithIntegerCheck((((x1186*x1196))+((x1186*x1194))+(((-1.0)*x1196))+(((-1.0)*x1194))),-1);
if(!x1198.valid){
continue;
}
CheckValue<IkReal> x1199=IKPowWithIntegerCheck(sj1,-1);
if(!x1199.valid){
continue;
}
if( IKabs(((x1198.value)*(((((-1.0)*cj6*r01*x1188*x1191))+(((21.12)*cj6*r00*r01*sj1*x1187))+((x1192*x1195))+((x1192*x1197))+((x1187*x1193*(r00*r00)))+(((-1.0)*r00*x1189*x1191))+((x1190*x1197))+((x1190*x1195))+(((-1.0)*x1187*x1193*(r01*r01)))+(((-1.0)*r00*x1188*x1193)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0303030303030303)*(x1199.value)*(((((-32.0)*sj6*x1189))+(((32.0)*r00*x1187))+(((-32.0)*x1188)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1198.value)*(((((-1.0)*cj6*r01*x1188*x1191))+(((21.12)*cj6*r00*r01*sj1*x1187))+((x1192*x1195))+((x1192*x1197))+((x1187*x1193*(r00*r00)))+(((-1.0)*r00*x1189*x1191))+((x1190*x1197))+((x1190*x1195))+(((-1.0)*x1187*x1193*(r01*r01)))+(((-1.0)*r00*x1188*x1193))))))+IKsqr(((0.0303030303030303)*(x1199.value)*(((((-32.0)*sj6*x1189))+(((32.0)*r00*x1187))+(((-32.0)*x1188))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1198.value)*(((((-1.0)*cj6*r01*x1188*x1191))+(((21.12)*cj6*r00*r01*sj1*x1187))+((x1192*x1195))+((x1192*x1197))+((x1187*x1193*(r00*r00)))+(((-1.0)*r00*x1189*x1191))+((x1190*x1197))+((x1190*x1195))+(((-1.0)*x1187*x1193*(r01*r01)))+(((-1.0)*r00*x1188*x1193))))), ((0.0303030303030303)*(x1199.value)*(((((-32.0)*sj6*x1189))+(((32.0)*r00*x1187))+(((-32.0)*x1188))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1200=IKcos(j0);
IkReal x1201=IKsin(j0);
IkReal x1202=((0.32)*sj5);
IkReal x1203=(cj6*r10);
IkReal x1204=(r01*sj6);
IkReal x1205=((0.33)*cj1);
IkReal x1206=(pz*sj6);
IkReal x1207=((1.0)*r20);
IkReal x1208=(cj6*pz);
IkReal x1209=(r11*sj6);
IkReal x1210=((0.32)*cj5);
IkReal x1211=(cj6*r00);
IkReal x1212=((0.33)*sj1*x1200);
IkReal x1213=((0.33)*sj1*x1201);
evalcond[0]=((((-1.0)*r02*x1210))+(((-1.0)*x1202*x1204))+(((-1.0)*x1212))+((x1202*x1211)));
evalcond[1]=(((x1202*x1203))+(((-1.0)*x1202*x1209))+(((-1.0)*r12*x1210))+(((-1.0)*x1213)));
evalcond[2]=((((-1.0)*r02*x1212))+(((-1.0)*pz*r22))+(((-1.0)*r22*x1205))+(((-1.0)*r12*x1213))+(((-1.0)*x1210)));
evalcond[3]=((((-1.0)*r00*sj6*x1212))+(((-1.0)*cj6*r21*x1205))+(((-1.0)*r21*x1208))+(((-1.0)*cj6*r11*x1213))+(((-1.0)*r10*sj6*x1213))+(((-1.0)*cj6*r01*x1212))+(((-1.0)*x1206*x1207))+(((-1.0)*r20*sj6*x1205)));
evalcond[4]=(x1202+(((-1.0)*x1203*x1213))+((x1204*x1212))+(((-1.0)*cj6*r20*x1205))+((r21*x1206))+((r21*sj6*x1205))+(((-1.0)*x1211*x1212))+((x1209*x1213))+(((-1.0)*x1207*x1208)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1214=((32.0)*cj5);
IkReal x1215=((32.0)*sj5*sj6);
IkReal x1216=((32.0)*cj6*sj5);
CheckValue<IkReal> x1217=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x1217.valid){
continue;
}
CheckValue<IkReal> x1218 = IKatan2WithCheck(IkReal((((r10*x1216))+(((-1.0)*r12*x1214))+(((-1.0)*r11*x1215)))),IkReal(((((-1.0)*r02*x1214))+((r00*x1216))+(((-1.0)*r01*x1215)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1218.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1217.value)))+(x1218.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1219=IKcos(j0);
IkReal x1220=IKsin(j0);
IkReal x1221=((0.32)*sj5);
IkReal x1222=(cj6*r10);
IkReal x1223=(r01*sj6);
IkReal x1224=((0.33)*cj1);
IkReal x1225=(pz*sj6);
IkReal x1226=((1.0)*r20);
IkReal x1227=(cj6*pz);
IkReal x1228=(r11*sj6);
IkReal x1229=((0.32)*cj5);
IkReal x1230=(cj6*r00);
IkReal x1231=((0.33)*sj1*x1219);
IkReal x1232=((0.33)*sj1*x1220);
evalcond[0]=((((-1.0)*x1231))+(((-1.0)*x1221*x1223))+((x1221*x1230))+(((-1.0)*r02*x1229)));
evalcond[1]=((((-1.0)*x1232))+(((-1.0)*x1221*x1228))+(((-1.0)*r12*x1229))+((x1221*x1222)));
evalcond[2]=((((-1.0)*x1229))+(((-1.0)*pz*r22))+(((-1.0)*r12*x1232))+(((-1.0)*r22*x1224))+(((-1.0)*r02*x1231)));
evalcond[3]=((((-1.0)*r10*sj6*x1232))+(((-1.0)*cj6*r11*x1232))+(((-1.0)*x1225*x1226))+(((-1.0)*cj6*r21*x1224))+(((-1.0)*r20*sj6*x1224))+(((-1.0)*r00*sj6*x1231))+(((-1.0)*r21*x1227))+(((-1.0)*cj6*r01*x1231)));
evalcond[4]=(x1221+((r21*sj6*x1224))+(((-1.0)*x1230*x1231))+((x1223*x1231))+(((-1.0)*x1226*x1227))+(((-1.0)*x1222*x1232))+(((-1.0)*cj6*r20*x1224))+((x1228*x1232))+((r21*x1225)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1233=sj1*sj1;
IkReal x1234=((0.66)*sj1);
IkReal x1235=((0.4356)*x1233);
CheckValue<IkReal> x1238 = IKatan2WithCheck(IkReal((px*x1234)),IkReal((py*x1234)),IKFAST_ATAN2_MAGTHRESH);
if(!x1238.valid){
continue;
}
IkReal x1236=((1.0)*(x1238.value));
if(((((x1235*(py*py)))+((x1235*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x1239=IKPowWithIntegerCheck(IKabs(IKsqrt((((x1235*(py*py)))+((x1235*(px*px)))))),-1);
if(!x1239.valid){
continue;
}
if( (((x1239.value)*(((0.0065)+(((0.66)*cj1*pz))+pp)))) < -1-IKFAST_SINCOS_THRESH || (((x1239.value)*(((0.0065)+(((0.66)*cj1*pz))+pp)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1237=IKasin(((x1239.value)*(((0.0065)+(((0.66)*cj1*pz))+pp))));
j0array[0]=((((-1.0)*x1237))+(((-1.0)*x1236)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x1237+(((-1.0)*x1236)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1240=((1.03125)*sj1);
cj5array[0]=((((-1.03125)*cj1*r22))+(((-3.125)*npz))+(((-1.0)*r12*sj0*x1240))+(((-1.0)*cj0*r02*x1240)));
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j6eval[3];
IkReal x1241=(r12*sj5);
IkReal x1242=((8.0)*cj5);
IkReal x1243=((8.25)*cj1);
IkReal x1244=((8.25)*cj0*sj1);
j6eval[0]=x1241;
j6eval[1]=((IKabs((((r20*x1244))+(((-1.0)*r11*x1242))+(((25.0)*rxp0_1))+(((-1.0)*r00*x1243)))))+(IKabs(((((25.0)*rxp1_1))+((r21*x1244))+(((-1.0)*r01*x1243))+((r10*x1242))))));
j6eval[2]=IKsign(x1241);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1245=((16.5)*cj1);
IkReal x1246=((16.0)*npx);
IkReal x1247=(cj5*r22);
IkReal x1248=((50.0)*pz);
IkReal x1249=((25.0)*pp);
IkReal x1250=(r21*sj5);
IkReal x1251=(npy*r20*sj5);
IkReal x1252=((16.0)*cj5*npz);
j6eval[0]=(x1251+(((-1.0)*npx*x1250)));
j6eval[1]=IKsign(((((16.0)*x1251))+(((-1.0)*x1246*x1250))));
j6eval[2]=((IKabs(((((0.1625)*r21))+(((-1.0)*r21*x1252))+(((-1.0)*r21*x1249))+(((16.0)*npy*x1247))+((npy*x1248))+((npy*x1245)))))+(IKabs(((((0.1625)*r20))+(((-1.0)*r20*x1252))+((npx*x1245))+((npx*x1248))+(((-1.0)*r20*x1249))+((x1246*x1247))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1253=((16.0)*cj5);
IkReal x1254=((25.0)*pp);
IkReal x1255=((50.0)*px);
IkReal x1256=(npy*r00*sj5);
IkReal x1257=(npx*r01*sj5);
IkReal x1258=((16.5)*cj0*sj1);
j6eval[0]=(x1256+(((-1.0)*x1257)));
j6eval[1]=IKsign(((((16.0)*x1256))+(((-16.0)*x1257))));
j6eval[2]=((IKabs((((npy*r02*x1253))+(((-1.0)*npz*r01*x1253))+(((-1.0)*r01*x1254))+((npy*x1258))+((npy*x1255))+(((0.1625)*r01)))))+(IKabs((((npx*x1255))+((npx*x1258))+(((-1.0)*r00*x1254))+(((-1.0)*npz*r00*x1253))+((npx*r02*x1253))+(((0.1625)*r00))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1259=((0.33)*sj1);
IkReal x1260=((0.33)*cj1);
j6eval[0]=((IKabs(((((-1.0)*npx))+(((-1.0)*r10*sj0*x1259))+(((-1.0)*cj0*r00*x1259))+(((-1.0)*r20*x1260)))))+(IKabs((((r11*sj0*x1259))+((r21*x1260))+npy+((cj0*r01*x1259))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1261=((0.33)*sj1);
IkReal x1262=((0.33)*cj1);
j6eval[0]=((IKabs(((((-1.0)*r21*x1262))+(((-1.0)*npy))+(((-1.0)*r11*sj0*x1261))+(((-1.0)*cj0*r01*x1261)))))+(IKabs(((((-1.0)*r10*sj0*x1261))+(((-1.0)*npx))+(((-1.0)*cj0*r00*x1261))+(((-1.0)*r20*x1262))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1263=((0.33)*sj1);
IkReal x1264=((0.33)*cj1);
CheckValue<IkReal> x1266 = IKatan2WithCheck(IkReal(((((-1.0)*r21*x1264))+(((-1.0)*npy))+(((-1.0)*r11*sj0*x1263))+(((-1.0)*cj0*r01*x1263)))),IkReal(((((-1.0)*r10*sj0*x1263))+(((-1.0)*npx))+(((-1.0)*cj0*r00*x1263))+(((-1.0)*r20*x1264)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1266.valid){
continue;
}
IkReal x1265=x1266.value;
j6array[0]=((-1.0)*x1265);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1265)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1267=IKsin(j6);
IkReal x1268=IKcos(j6);
IkReal x1269=((0.33)*sj1);
IkReal x1270=((0.33)*cj1);
evalcond[0]=(((cj0*r01*x1267*x1269))+((npy*x1267))+(((-1.0)*r20*x1268*x1270))+((r11*sj0*x1267*x1269))+(((-1.0)*npx*x1268))+(((-1.0)*cj0*r00*x1268*x1269))+(((-1.0)*r10*sj0*x1268*x1269))+((r21*x1267*x1270)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1271=((0.33)*sj1);
IkReal x1272=((0.33)*cj1);
CheckValue<IkReal> x1274 = IKatan2WithCheck(IkReal(((((-1.0)*r10*sj0*x1271))+(((-1.0)*npx))+(((-1.0)*cj0*r00*x1271))+(((-1.0)*r20*x1272)))),IkReal((((r21*x1272))+npy+((cj0*r01*x1271))+((r11*sj0*x1271)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1274.valid){
continue;
}
IkReal x1273=x1274.value;
j6array[0]=((-1.0)*x1273);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1273)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1275=IKsin(j6);
IkReal x1276=IKcos(j6);
IkReal x1277=((0.33)*x1275);
IkReal x1278=((0.33)*sj1*x1276);
evalcond[0]=((((-1.0)*cj1*r20*x1277))+(((-1.0)*cj0*r00*sj1*x1277))+(((-1.0)*r10*sj0*sj1*x1277))+(((-1.0)*r11*sj0*x1278))+(((-0.33)*cj1*r21*x1276))+(((-1.0)*cj0*r01*x1278))+(((-1.0)*npx*x1275))+(((-1.0)*npy*x1276)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1279=((0.33)*sj1);
IkReal x1280=((0.33)*cj1);
j6eval[0]=((IKabs(((((-1.0)*r10*sj0*x1279))+(((-1.0)*npx))+(((-1.0)*cj0*r00*x1279))+(((-1.0)*r20*x1280)))))+(IKabs((npy+((cj0*r01*x1279))+((r21*x1280))+((r11*sj0*x1279))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1281=((0.33)*sj1);
IkReal x1282=((0.33)*cj1);
j6eval[0]=((IKabs(((((-1.0)*cj0*r01*x1281))+(((-1.0)*npy))+(((-1.0)*r21*x1282))+(((-1.0)*r11*sj0*x1281)))))+(IKabs(((((-1.0)*r10*sj0*x1281))+(((-1.0)*cj0*r00*x1281))+(((-1.0)*npx))+(((-1.0)*r20*x1282))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1283=((0.33)*sj1);
IkReal x1284=((0.33)*cj1);
CheckValue<IkReal> x1286 = IKatan2WithCheck(IkReal(((((-1.0)*cj0*r01*x1283))+(((-1.0)*npy))+(((-1.0)*r21*x1284))+(((-1.0)*r11*sj0*x1283)))),IkReal(((((-1.0)*r10*sj0*x1283))+(((-1.0)*cj0*r00*x1283))+(((-1.0)*npx))+(((-1.0)*r20*x1284)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1286.valid){
continue;
}
IkReal x1285=x1286.value;
j6array[0]=((-1.0)*x1285);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1285)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1287=IKsin(j6);
IkReal x1288=IKcos(j6);
IkReal x1289=((0.33)*sj1);
IkReal x1290=((0.33)*cj1);
evalcond[0]=((((-1.0)*r10*sj0*x1288*x1289))+(((-1.0)*npx*x1288))+(((-1.0)*r20*x1288*x1290))+((cj0*r01*x1287*x1289))+(((-1.0)*cj0*r00*x1288*x1289))+((r11*sj0*x1287*x1289))+((r21*x1287*x1290))+((npy*x1287)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1291=((0.33)*sj1);
IkReal x1292=((0.33)*cj1);
CheckValue<IkReal> x1294 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x1292))+(((-1.0)*npx))+(((-1.0)*r10*sj0*x1291))+(((-1.0)*cj0*r00*x1291)))),IkReal((((r21*x1292))+((cj0*r01*x1291))+npy+((r11*sj0*x1291)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1294.valid){
continue;
}
IkReal x1293=x1294.value;
j6array[0]=((-1.0)*x1293);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1293)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1295=IKsin(j6);
IkReal x1296=IKcos(j6);
IkReal x1297=((0.33)*x1295);
IkReal x1298=((0.33)*sj1*x1296);
evalcond[0]=((((-1.0)*npy*x1296))+(((-1.0)*cj1*r20*x1297))+(((-1.0)*r10*sj0*sj1*x1297))+(((-1.0)*r11*sj0*x1298))+(((-0.33)*cj1*r21*x1296))+(((-1.0)*cj0*r00*sj1*x1297))+(((-1.0)*cj0*r01*x1298))+(((-1.0)*npx*x1295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r12);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
IkReal x1299=(r02*sj5);
IkReal x1300=((8.25)*cj1);
IkReal x1301=((8.25)*sj0*sj1);
IkReal x1302=((8.0)*cj5*r22);
j6eval[0]=x1299;
j6eval[1]=IKsign(x1299);
j6eval[2]=((IKabs(((((-25.0)*rxp0_0))+(((-1.0)*r10*x1302))+(((-1.0)*r10*x1300))+((r20*x1301)))))+(IKabs(((((-25.0)*rxp1_0))+((r21*x1301))+(((-1.0)*r11*x1300))+(((-1.0)*r11*x1302))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
IkReal x1303=(r22*sj5);
IkReal x1304=((8.25)*sj1);
IkReal x1305=((8.0)*cj5*r02);
j6eval[0]=x1303;
j6eval[1]=IKsign(x1303);
j6eval[2]=((IKabs((((r10*x1305))+(((-25.0)*rxp0_2))+((cj0*r10*x1304))+(((-1.0)*r00*sj0*x1304)))))+(IKabs((((cj0*r11*x1304))+(((-1.0)*r01*sj0*x1304))+(((-25.0)*rxp1_2))+((r11*x1305))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
IkReal x1306=((50.0)*py);
IkReal x1307=((16.0)*r10);
IkReal x1308=(npy*sj5);
IkReal x1309=((25.0)*pp);
IkReal x1310=((16.0)*r11);
IkReal x1311=(cj5*pz*r22);
IkReal x1312=(npx*r11*sj5);
IkReal x1313=((16.5)*sj0*sj1);
IkReal x1314=(cj5*px*r02);
j6eval[0]=(((r10*x1308))+(((-1.0)*x1312)));
j6eval[1]=((IKabs(((((-1.0)*r11*x1309))+((npy*x1306))+(((-1.0)*x1310*x1311))+(((-1.0)*x1310*x1314))+(((0.1625)*r11))+((npy*x1313)))))+(IKabs((((npx*x1313))+((npx*x1306))+(((-1.0)*x1307*x1311))+(((-1.0)*x1307*x1314))+(((-1.0)*r10*x1309))+(((0.1625)*r10))))));
j6eval[2]=IKsign((((x1307*x1308))+(((-1.0)*npx*sj5*x1310))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1315=((0.32)*r02);
IkReal x1316=((0.33)*cj1);
IkReal x1317=((1.0)*pz);
j6eval[0]=((IKabs((((r01*x1315))+(((-1.0)*r21*x1316))+(((-1.0)*r21*x1317)))))+(IKabs((((r00*x1315))+(((-1.0)*r20*x1317))+(((-1.0)*r20*x1316))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1318=((0.32)*r02);
IkReal x1319=((0.33)*cj1);
j6eval[0]=((IKabs((((r00*x1318))+(((-1.0)*pz*r20))+(((-1.0)*r20*x1319)))))+(IKabs(((((-1.0)*r01*x1318))+((r21*x1319))+((pz*r21))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1320=((0.32)*r02);
IkReal x1321=((0.33)*cj1);
CheckValue<IkReal> x1323 = IKatan2WithCheck(IkReal((((r00*x1320))+((px*r00))+(((-1.0)*npx))+(((-1.0)*r20*x1321))+((py*r10)))),IkReal(((((-1.0)*px*r01))+(((-1.0)*r01*x1320))+npy+((r21*x1321))+(((-1.0)*py*r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1323.valid){
continue;
}
IkReal x1322=x1323.value;
j6array[0]=((-1.0)*x1322);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1322)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1324=IKsin(j6);
IkReal x1325=IKcos(j6);
IkReal x1326=((0.32)*r02);
IkReal x1327=((0.33)*cj1);
IkReal x1328=(r00*x1324);
IkReal x1329=(r01*x1325);
evalcond[0]=((((-1.0)*r20*x1324*x1327))+((px*x1328))+((px*x1329))+((py*r10*x1324))+((x1326*x1329))+((x1326*x1328))+((py*r11*x1325))+(((-1.0)*npy*x1325))+(((-1.0)*npx*x1324))+(((-1.0)*r21*x1325*x1327)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1330=((0.32)*r02);
IkReal x1331=((0.33)*cj1);
CheckValue<IkReal> x1333 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+((r01*x1330))+((py*r11))+(((-1.0)*r21*x1331)))),IkReal((((px*r00))+((r00*x1330))+(((-1.0)*npx))+(((-1.0)*r20*x1331))+((py*r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1333.valid){
continue;
}
IkReal x1332=x1333.value;
j6array[0]=((-1.0)*x1332);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1332)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1334=IKcos(j6);
IkReal x1335=IKsin(j6);
IkReal x1336=((0.33)*cj1);
IkReal x1337=((0.32)*r02);
IkReal x1338=(r00*x1334);
IkReal x1339=((1.0)*x1335);
evalcond[0]=(((px*x1338))+((x1337*x1338))+((r21*x1335*x1336))+(((-1.0)*r20*x1334*x1336))+(((-1.0)*px*r01*x1339))+((npy*x1335))+(((-1.0)*npx*x1334))+(((-1.0)*py*r11*x1339))+((py*r10*x1334))+(((-1.0)*r01*x1335*x1337)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1340=((0.32)*r02);
IkReal x1341=((0.33)*cj1);
IkReal x1342=((1.0)*pz);
j6eval[0]=((IKabs(((((-1.0)*r21*x1342))+(((-1.0)*r21*x1341))+(((-1.0)*r01*x1340)))))+(IKabs(((((-1.0)*r20*x1341))+(((-1.0)*r20*x1342))+(((-1.0)*r00*x1340))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1343=((0.32)*r02);
IkReal x1344=((0.33)*cj1);
j6eval[0]=((IKabs(((((-1.0)*r20*x1344))+(((-1.0)*pz*r20))+(((-1.0)*r00*x1343)))))+(IKabs((((r01*x1343))+((pz*r21))+((r21*x1344))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1345=((0.32)*r02);
IkReal x1346=((0.33)*cj1);
CheckValue<IkReal> x1348 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x1346))+((px*r00))+(((-1.0)*npx))+(((-1.0)*r00*x1345))+((py*r10)))),IkReal(((((-1.0)*px*r01))+npy+(((-1.0)*py*r11))+((r01*x1345))+((r21*x1346)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1348.valid){
continue;
}
IkReal x1347=x1348.value;
j6array[0]=((-1.0)*x1347);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1347)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1349=IKsin(j6);
IkReal x1350=IKcos(j6);
IkReal x1351=((0.32)*r02);
IkReal x1352=((0.33)*cj1);
IkReal x1353=(r00*x1349);
IkReal x1354=(r01*x1350);
evalcond[0]=((((-1.0)*npy*x1350))+((py*r10*x1349))+((py*r11*x1350))+(((-1.0)*r20*x1349*x1352))+((px*x1353))+((px*x1354))+(((-1.0)*x1351*x1353))+(((-1.0)*x1351*x1354))+(((-1.0)*npx*x1349))+(((-1.0)*r21*x1350*x1352)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1355=((0.32)*r02);
IkReal x1356=((0.33)*cj1);
CheckValue<IkReal> x1358 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*r21*x1356))+(((-1.0)*npy))+(((-1.0)*r01*x1355))+((py*r11)))),IkReal((((px*r00))+(((-1.0)*r20*x1356))+(((-1.0)*npx))+(((-1.0)*r00*x1355))+((py*r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1358.valid){
continue;
}
IkReal x1357=x1358.value;
j6array[0]=((-1.0)*x1357);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1357)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1359=IKcos(j6);
IkReal x1360=IKsin(j6);
IkReal x1361=((0.33)*cj1);
IkReal x1362=((0.32)*r02);
IkReal x1363=(r00*x1359);
IkReal x1364=((1.0)*x1360);
evalcond[0]=(((npy*x1360))+((r21*x1360*x1361))+((py*r10*x1359))+(((-1.0)*px*r01*x1364))+(((-1.0)*r20*x1359*x1361))+(((-1.0)*x1362*x1363))+((px*x1363))+(((-1.0)*npx*x1359))+(((-1.0)*py*r11*x1364))+((r01*x1360*x1362)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r02);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
IkReal x1365=(r22*sj5);
IkReal x1366=((8.25)*sj1);
j6eval[0]=x1365;
j6eval[1]=((IKabs((((cj0*r11*x1366))+(((-25.0)*rxp1_2))+(((-1.0)*r01*sj0*x1366)))))+(IKabs(((((-25.0)*rxp0_2))+(((-1.0)*r00*sj0*x1366))+((cj0*r10*x1366))))));
j6eval[2]=IKsign(x1365);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
IkReal x1367=((25.0)*pp);
IkReal x1368=((16.0)*r00);
IkReal x1369=(npy*sj5);
IkReal x1370=((50.0)*px);
IkReal x1371=(npx*r01*sj5);
IkReal x1372=((16.5)*cj0*sj1);
IkReal x1373=(cj5*pz*r22);
j6eval[0]=((((-1.0)*x1371))+((r00*x1369)));
j6eval[1]=((IKabs((((npx*x1370))+((npx*x1372))+(((-1.0)*r00*x1367))+(((-1.0)*x1368*x1373))+(((0.1625)*r00)))))+(IKabs(((((-16.0)*r01*x1373))+(((-1.0)*r01*x1367))+((npy*x1372))+((npy*x1370))+(((0.1625)*r01))))));
j6eval[2]=IKsign(((((-16.0)*x1371))+((x1368*x1369))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
IkReal x1374=((50.0)*py);
IkReal x1375=((16.0)*r10);
IkReal x1376=(npy*sj5);
IkReal x1377=((25.0)*pp);
IkReal x1378=(cj5*pz*r22);
IkReal x1379=(npx*r11*sj5);
IkReal x1380=((16.5)*sj0*sj1);
j6eval[0]=(((r10*x1376))+(((-1.0)*x1379)));
j6eval[1]=((IKabs((((npx*x1374))+((npx*x1380))+(((-1.0)*x1375*x1378))+(((-1.0)*r10*x1377))+(((0.1625)*r10)))))+(IKabs((((npy*x1380))+(((-1.0)*r11*x1377))+((npy*x1374))+(((-16.0)*r11*x1378))+(((0.1625)*r11))))));
j6eval[2]=IKsign((((x1375*x1376))+(((-16.0)*x1379))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1381=((1.0)*pz);
IkReal x1382=((0.33)*cj1);
j6eval[0]=((IKabs(((((-1.0)*r20*x1382))+(((-1.0)*r20*x1381)))))+(IKabs(((((-1.0)*r21*x1381))+(((-1.0)*r21*x1382))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1383=((0.33)*cj1);
j6eval[0]=((IKabs((((r21*x1383))+((pz*r21)))))+(IKabs(((((-1.0)*r20*x1383))+(((-1.0)*pz*r20))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1384=((0.33)*cj1);
CheckValue<IkReal> x1386 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x1384))+((px*r00))+(((-1.0)*npx))+((py*r10)))),IkReal(((((-1.0)*px*r01))+((r21*x1384))+npy+(((-1.0)*py*r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1386.valid){
continue;
}
IkReal x1385=x1386.value;
j6array[0]=((-1.0)*x1385);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1385)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1387=IKsin(j6);
IkReal x1388=IKcos(j6);
IkReal x1389=((0.33)*cj1);
evalcond[0]=((((-1.0)*r21*x1388*x1389))+((py*r10*x1387))+(((-1.0)*r20*x1387*x1389))+(((-1.0)*npy*x1388))+((px*r00*x1387))+(((-1.0)*npx*x1387))+((px*r01*x1388))+((py*r11*x1388)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1390=((0.33)*cj1);
CheckValue<IkReal> x1392 = IKatan2WithCheck(IkReal(((((-1.0)*r21*x1390))+((px*r01))+(((-1.0)*npy))+((py*r11)))),IkReal((((px*r00))+(((-1.0)*r20*x1390))+(((-1.0)*npx))+((py*r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1392.valid){
continue;
}
IkReal x1391=x1392.value;
j6array[0]=((-1.0)*x1391);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1391)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1393=IKcos(j6);
IkReal x1394=IKsin(j6);
IkReal x1395=((0.33)*cj1);
IkReal x1396=((1.0)*x1394);
evalcond[0]=(((npy*x1394))+(((-1.0)*py*r11*x1396))+(((-1.0)*npx*x1393))+((r21*x1394*x1395))+(((-1.0)*px*r01*x1396))+((px*r00*x1393))+(((-1.0)*r20*x1393*x1395))+((py*r10*x1393)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1397=((1.0)*pz);
IkReal x1398=((0.33)*cj1);
j6eval[0]=((IKabs(((((-1.0)*r20*x1397))+(((-1.0)*r20*x1398)))))+(IKabs(((((-1.0)*r21*x1398))+(((-1.0)*r21*x1397))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1399=((0.33)*cj1);
j6eval[0]=((IKabs((((r21*x1399))+((pz*r21)))))+(IKabs(((((-1.0)*pz*r20))+(((-1.0)*r20*x1399))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1400=((0.33)*cj1);
CheckValue<IkReal> x1402 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+((py*r10))+(((-1.0)*r20*x1400)))),IkReal(((((-1.0)*px*r01))+npy+((r21*x1400))+(((-1.0)*py*r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1402.valid){
continue;
}
IkReal x1401=x1402.value;
j6array[0]=((-1.0)*x1401);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1401)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1403=IKsin(j6);
IkReal x1404=IKcos(j6);
IkReal x1405=((0.33)*cj1);
evalcond[0]=(((px*r01*x1404))+((px*r00*x1403))+(((-1.0)*r20*x1403*x1405))+((py*r10*x1403))+(((-1.0)*r21*x1404*x1405))+((py*r11*x1404))+(((-1.0)*npx*x1403))+(((-1.0)*npy*x1404)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1406=((0.33)*cj1);
CheckValue<IkReal> x1408 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+((py*r11))+(((-1.0)*r21*x1406)))),IkReal((((px*r00))+(((-1.0)*npx))+((py*r10))+(((-1.0)*r20*x1406)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1408.valid){
continue;
}
IkReal x1407=x1408.value;
j6array[0]=((-1.0)*x1407);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1407)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1409=IKcos(j6);
IkReal x1410=IKsin(j6);
IkReal x1411=((0.33)*cj1);
IkReal x1412=((1.0)*x1410);
evalcond[0]=((((-1.0)*r20*x1409*x1411))+((px*r00*x1409))+(((-1.0)*py*r11*x1412))+((py*r10*x1409))+((r21*x1410*x1411))+(((-1.0)*npx*x1409))+((npy*x1410))+(((-1.0)*px*r01*x1412)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1413=((50.0)*py);
IkReal x1414=((16.0)*r10);
IkReal x1415=((25.0)*pp);
IkReal x1416=((16.0)*r11);
IkReal x1417=(cj5*pz*r22);
IkReal x1418=((16.5)*sj0*sj1);
CheckValue<IkReal> x1419 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1415))+(((-1.0)*x1414*x1417))+(((0.1625)*r10))+((npx*x1418))+((npx*x1413)))),IkReal(((((-1.0)*x1416*x1417))+(((-1.0)*r11*x1415))+(((0.1625)*r11))+((npy*x1418))+((npy*x1413)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1419.valid){
continue;
}
CheckValue<IkReal> x1420=IKPowWithIntegerCheck(IKsign(((((-1.0)*npx*sj5*x1416))+((npy*sj5*x1414)))),-1);
if(!x1420.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1419.value)+(((1.5707963267949)*(x1420.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1421=IKcos(j6);
IkReal x1422=IKsin(j6);
IkReal x1423=((0.64)*sj5);
IkReal x1424=((0.32)*sj5);
IkReal x1425=(cj5*r22);
IkReal x1426=(cj0*sj1);
IkReal x1427=(cj1*r20);
IkReal x1428=(cj1*r21);
IkReal x1429=(npy*x1422);
IkReal x1430=((0.33)*sj0*sj1);
IkReal x1431=((0.33)*x1422);
IkReal x1432=((0.33)*x1421);
IkReal x1433=(r10*x1421);
IkReal x1434=(r11*x1422);
IkReal x1435=((1.0)*x1421);
evalcond[0]=((((-0.33)*x1426))+(((-1.0)*r01*x1422*x1424))+(((-1.0)*px))+((r00*x1421*x1424)));
evalcond[1]=((((-1.0)*x1430))+((x1424*x1433))+(((-1.0)*py))+(((-1.0)*x1424*x1434)));
evalcond[2]=((0.0065)+((npx*x1421*x1423))+(((-0.64)*pz*x1425))+(((-1.0)*x1423*x1429))+(((-1.0)*pp)));
evalcond[3]=((((-1.0)*pz))+(((-0.32)*x1425))+((r20*x1421*x1424))+(((-1.0)*r21*x1422*x1424))+(((-0.33)*cj1)));
evalcond[4]=((((-1.0)*npx*x1422))+(((-1.0)*r11*x1421*x1430))+(((-1.0)*x1428*x1432))+(((-1.0)*npy*x1435))+(((-1.0)*r01*x1426*x1432))+(((-1.0)*x1427*x1431))+(((-1.0)*r10*x1422*x1430))+(((-1.0)*r00*x1426*x1431)));
evalcond[5]=(((r01*x1426*x1431))+((x1428*x1431))+((x1430*x1434))+(((-1.0)*npx*x1435))+x1424+x1429+(((-1.0)*x1427*x1432))+(((-1.0)*x1430*x1433))+(((-1.0)*r00*x1426*x1432)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1436=((25.0)*pp);
IkReal x1437=((16.0)*r00);
IkReal x1438=((50.0)*px);
IkReal x1439=((16.0)*r01);
IkReal x1440=((16.5)*cj0*sj1);
IkReal x1441=(cj5*pz*r22);
CheckValue<IkReal> x1442 = IKatan2WithCheck(IkReal((((npx*x1438))+(((-1.0)*x1437*x1441))+(((-1.0)*r00*x1436))+((npx*x1440))+(((0.1625)*r00)))),IkReal((((npy*x1440))+(((-1.0)*x1439*x1441))+((npy*x1438))+(((-1.0)*r01*x1436))+(((0.1625)*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1442.valid){
continue;
}
CheckValue<IkReal> x1443=IKPowWithIntegerCheck(IKsign(((((-1.0)*npx*sj5*x1439))+((npy*sj5*x1437)))),-1);
if(!x1443.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1442.value)+(((1.5707963267949)*(x1443.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1444=IKcos(j6);
IkReal x1445=IKsin(j6);
IkReal x1446=((0.64)*sj5);
IkReal x1447=((0.32)*sj5);
IkReal x1448=(cj5*r22);
IkReal x1449=(cj0*sj1);
IkReal x1450=(cj1*r20);
IkReal x1451=(cj1*r21);
IkReal x1452=(npy*x1445);
IkReal x1453=((0.33)*sj0*sj1);
IkReal x1454=((0.33)*x1445);
IkReal x1455=((0.33)*x1444);
IkReal x1456=(r10*x1444);
IkReal x1457=(r11*x1445);
IkReal x1458=((1.0)*x1444);
evalcond[0]=((((-1.0)*r01*x1445*x1447))+(((-0.33)*x1449))+(((-1.0)*px))+((r00*x1444*x1447)));
evalcond[1]=((((-1.0)*x1447*x1457))+((x1447*x1456))+(((-1.0)*x1453))+(((-1.0)*py)));
evalcond[2]=((0.0065)+(((-1.0)*pp))+(((-1.0)*x1446*x1452))+(((-0.64)*pz*x1448))+((npx*x1444*x1446)));
evalcond[3]=((((-1.0)*r21*x1445*x1447))+((r20*x1444*x1447))+(((-1.0)*pz))+(((-0.32)*x1448))+(((-0.33)*cj1)));
evalcond[4]=((((-1.0)*npx*x1445))+(((-1.0)*r01*x1449*x1455))+(((-1.0)*r11*x1444*x1453))+(((-1.0)*npy*x1458))+(((-1.0)*r00*x1449*x1454))+(((-1.0)*x1451*x1455))+(((-1.0)*r10*x1445*x1453))+(((-1.0)*x1450*x1454)));
evalcond[5]=((((-1.0)*npx*x1458))+(((-1.0)*x1453*x1456))+x1452+x1447+(((-1.0)*r00*x1449*x1455))+((r01*x1449*x1454))+((x1453*x1457))+((x1451*x1454))+(((-1.0)*x1450*x1455)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1459=((8.25)*sj1);
CheckValue<IkReal> x1460 = IKatan2WithCheck(IkReal(((((-1.0)*r00*sj0*x1459))+(((-25.0)*rxp0_2))+((cj0*r10*x1459)))),IkReal(((((-1.0)*r01*sj0*x1459))+(((-25.0)*rxp1_2))+((cj0*r11*x1459)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1460.valid){
continue;
}
CheckValue<IkReal> x1461=IKPowWithIntegerCheck(IKsign((r22*sj5)),-1);
if(!x1461.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1460.value)+(((1.5707963267949)*(x1461.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1462=IKcos(j6);
IkReal x1463=IKsin(j6);
IkReal x1464=((0.64)*sj5);
IkReal x1465=((0.32)*sj5);
IkReal x1466=(cj5*r22);
IkReal x1467=(cj0*sj1);
IkReal x1468=(cj1*r20);
IkReal x1469=(cj1*r21);
IkReal x1470=(npy*x1463);
IkReal x1471=((0.33)*sj0*sj1);
IkReal x1472=((0.33)*x1463);
IkReal x1473=((0.33)*x1462);
IkReal x1474=(r10*x1462);
IkReal x1475=(r11*x1463);
IkReal x1476=((1.0)*x1462);
evalcond[0]=((((-1.0)*r01*x1463*x1465))+(((-1.0)*px))+((r00*x1462*x1465))+(((-0.33)*x1467)));
evalcond[1]=((((-1.0)*x1465*x1475))+(((-1.0)*py))+(((-1.0)*x1471))+((x1465*x1474)));
evalcond[2]=((0.0065)+(((-0.64)*pz*x1466))+((npx*x1462*x1464))+(((-1.0)*pp))+(((-1.0)*x1464*x1470)));
evalcond[3]=((((-0.32)*x1466))+(((-1.0)*r21*x1463*x1465))+((r20*x1462*x1465))+(((-1.0)*pz))+(((-0.33)*cj1)));
evalcond[4]=((((-1.0)*r11*x1462*x1471))+(((-1.0)*npy*x1476))+(((-1.0)*r00*x1467*x1472))+(((-1.0)*npx*x1463))+(((-1.0)*x1468*x1472))+(((-1.0)*x1469*x1473))+(((-1.0)*r01*x1467*x1473))+(((-1.0)*r10*x1463*x1471)));
evalcond[5]=(((x1471*x1475))+(((-1.0)*x1471*x1474))+(((-1.0)*npx*x1476))+(((-1.0)*r00*x1467*x1473))+(((-1.0)*x1468*x1473))+x1465+x1470+((r01*x1467*x1472))+((x1469*x1472)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1477=((50.0)*py);
IkReal x1478=((16.0)*r10);
IkReal x1479=((25.0)*pp);
IkReal x1480=((16.0)*r11);
IkReal x1481=(cj5*pz*r22);
IkReal x1482=((16.5)*sj0*sj1);
IkReal x1483=(cj5*px*r02);
CheckValue<IkReal> x1484 = IKatan2WithCheck(IkReal((((npx*x1482))+(((-1.0)*r10*x1479))+((npx*x1477))+(((0.1625)*r10))+(((-1.0)*x1478*x1481))+(((-1.0)*x1478*x1483)))),IkReal((((npy*x1477))+((npy*x1482))+(((-1.0)*x1480*x1483))+(((-1.0)*x1480*x1481))+(((-1.0)*r11*x1479))+(((0.1625)*r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1484.valid){
continue;
}
CheckValue<IkReal> x1485=IKPowWithIntegerCheck(IKsign((((npy*sj5*x1478))+(((-1.0)*npx*sj5*x1480)))),-1);
if(!x1485.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1484.value)+(((1.5707963267949)*(x1485.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1486=IKcos(j6);
IkReal x1487=IKsin(j6);
IkReal x1488=((0.64)*sj5);
IkReal x1489=((0.32)*sj5);
IkReal x1490=(cj5*r22);
IkReal x1491=(cj0*sj1);
IkReal x1492=(cj1*r20);
IkReal x1493=(cj1*r21);
IkReal x1494=(cj5*r02);
IkReal x1495=(npy*x1487);
IkReal x1496=((0.33)*sj0*sj1);
IkReal x1497=((0.33)*x1487);
IkReal x1498=((0.33)*x1486);
IkReal x1499=(r10*x1486);
IkReal x1500=(r11*x1487);
IkReal x1501=((1.0)*x1486);
evalcond[0]=(((x1489*x1499))+(((-1.0)*x1496))+(((-1.0)*py))+(((-1.0)*x1489*x1500)));
evalcond[1]=((((-1.0)*r21*x1487*x1489))+(((-1.0)*pz))+(((-0.32)*x1490))+((r20*x1486*x1489))+(((-0.33)*cj1)));
evalcond[2]=((((-0.33)*x1491))+(((-1.0)*px))+((r00*x1486*x1489))+(((-0.32)*x1494))+(((-1.0)*r01*x1487*x1489)));
evalcond[3]=((0.0065)+((npx*x1486*x1488))+(((-0.64)*px*x1494))+(((-1.0)*pp))+(((-0.64)*pz*x1490))+(((-1.0)*x1488*x1495)));
evalcond[4]=((((-1.0)*r10*x1487*x1496))+(((-1.0)*r00*x1491*x1497))+(((-1.0)*x1492*x1497))+(((-1.0)*npy*x1501))+(((-1.0)*x1493*x1498))+(((-1.0)*r11*x1486*x1496))+(((-1.0)*npx*x1487))+(((-1.0)*r01*x1491*x1498)));
evalcond[5]=(((r01*x1491*x1497))+(((-1.0)*r00*x1491*x1498))+(((-1.0)*x1496*x1499))+(((-1.0)*x1492*x1498))+(((-1.0)*npx*x1501))+((x1496*x1500))+((x1493*x1497))+x1495+x1489);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1502=((8.25)*sj1);
IkReal x1503=((8.0)*cj5*r02);
CheckValue<IkReal> x1504 = IKatan2WithCheck(IkReal(((((-25.0)*rxp0_2))+((r10*x1503))+(((-1.0)*r00*sj0*x1502))+((cj0*r10*x1502)))),IkReal(((((-1.0)*r01*sj0*x1502))+((r11*x1503))+(((-25.0)*rxp1_2))+((cj0*r11*x1502)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1504.valid){
continue;
}
CheckValue<IkReal> x1505=IKPowWithIntegerCheck(IKsign((r22*sj5)),-1);
if(!x1505.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1504.value)+(((1.5707963267949)*(x1505.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1506=IKcos(j6);
IkReal x1507=IKsin(j6);
IkReal x1508=((0.64)*sj5);
IkReal x1509=((0.32)*sj5);
IkReal x1510=(cj5*r22);
IkReal x1511=(cj0*sj1);
IkReal x1512=(cj1*r20);
IkReal x1513=(cj1*r21);
IkReal x1514=(cj5*r02);
IkReal x1515=(npy*x1507);
IkReal x1516=((0.33)*sj0*sj1);
IkReal x1517=((0.33)*x1507);
IkReal x1518=((0.33)*x1506);
IkReal x1519=(r10*x1506);
IkReal x1520=(r11*x1507);
IkReal x1521=((1.0)*x1506);
evalcond[0]=(((x1509*x1519))+(((-1.0)*x1516))+(((-1.0)*py))+(((-1.0)*x1509*x1520)));
evalcond[1]=((((-0.32)*x1510))+(((-1.0)*pz))+((r20*x1506*x1509))+(((-1.0)*r21*x1507*x1509))+(((-0.33)*cj1)));
evalcond[2]=((((-0.33)*x1511))+((r00*x1506*x1509))+(((-0.32)*x1514))+(((-1.0)*px))+(((-1.0)*r01*x1507*x1509)));
evalcond[3]=((0.0065)+((npx*x1506*x1508))+(((-1.0)*pp))+(((-0.64)*px*x1514))+(((-1.0)*x1508*x1515))+(((-0.64)*pz*x1510)));
evalcond[4]=((((-1.0)*x1513*x1518))+(((-1.0)*r10*x1507*x1516))+(((-1.0)*npy*x1521))+(((-1.0)*npx*x1507))+(((-1.0)*r01*x1511*x1518))+(((-1.0)*r00*x1511*x1517))+(((-1.0)*x1512*x1517))+(((-1.0)*r11*x1506*x1516)));
evalcond[5]=(((x1513*x1517))+((r01*x1511*x1517))+(((-1.0)*x1516*x1519))+(((-1.0)*npx*x1521))+x1509+x1515+((x1516*x1520))+(((-1.0)*r00*x1511*x1518))+(((-1.0)*x1512*x1518)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1522=((8.25)*cj1);
IkReal x1523=((8.25)*sj0*sj1);
IkReal x1524=((8.0)*cj5*r22);
CheckValue<IkReal> x1525=IKPowWithIntegerCheck(IKsign((r02*sj5)),-1);
if(!x1525.valid){
continue;
}
CheckValue<IkReal> x1526 = IKatan2WithCheck(IkReal(((((-25.0)*rxp0_0))+((r20*x1523))+(((-1.0)*r10*x1522))+(((-1.0)*r10*x1524)))),IkReal(((((-1.0)*r11*x1524))+(((-1.0)*r11*x1522))+(((-25.0)*rxp1_0))+((r21*x1523)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1526.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1525.value)))+(x1526.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1527=IKcos(j6);
IkReal x1528=IKsin(j6);
IkReal x1529=((0.64)*sj5);
IkReal x1530=((0.32)*sj5);
IkReal x1531=(cj5*r22);
IkReal x1532=(cj0*sj1);
IkReal x1533=(cj1*r20);
IkReal x1534=(cj1*r21);
IkReal x1535=(cj5*r02);
IkReal x1536=(npy*x1528);
IkReal x1537=((0.33)*sj0*sj1);
IkReal x1538=((0.33)*x1528);
IkReal x1539=((0.33)*x1527);
IkReal x1540=(r10*x1527);
IkReal x1541=(r11*x1528);
IkReal x1542=((1.0)*x1527);
evalcond[0]=(((x1530*x1540))+(((-1.0)*x1537))+(((-1.0)*x1530*x1541))+(((-1.0)*py)));
evalcond[1]=(((r20*x1527*x1530))+(((-0.32)*x1531))+(((-1.0)*r21*x1528*x1530))+(((-1.0)*pz))+(((-0.33)*cj1)));
evalcond[2]=((((-0.33)*x1532))+((r00*x1527*x1530))+(((-0.32)*x1535))+(((-1.0)*px))+(((-1.0)*r01*x1528*x1530)));
evalcond[3]=((0.0065)+(((-1.0)*x1529*x1536))+(((-1.0)*pp))+((npx*x1527*x1529))+(((-0.64)*pz*x1531))+(((-0.64)*px*x1535)));
evalcond[4]=((((-1.0)*r01*x1532*x1539))+(((-1.0)*r10*x1528*x1537))+(((-1.0)*r11*x1527*x1537))+(((-1.0)*x1533*x1538))+(((-1.0)*npx*x1528))+(((-1.0)*x1534*x1539))+(((-1.0)*npy*x1542))+(((-1.0)*r00*x1532*x1538)));
evalcond[5]=(((x1537*x1541))+x1536+x1530+(((-1.0)*x1537*x1540))+(((-1.0)*x1533*x1539))+(((-1.0)*npx*x1542))+((x1534*x1538))+(((-1.0)*r00*x1532*x1539))+((r01*x1532*x1538)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1543=((16.0)*cj5);
IkReal x1544=((25.0)*pp);
IkReal x1545=((16.0)*sj5);
IkReal x1546=((50.0)*px);
IkReal x1547=((16.5)*cj0*sj1);
CheckValue<IkReal> x1548=IKPowWithIntegerCheck(IKsign((((npy*r00*x1545))+(((-1.0)*npx*r01*x1545)))),-1);
if(!x1548.valid){
continue;
}
CheckValue<IkReal> x1549 = IKatan2WithCheck(IkReal((((npx*r02*x1543))+(((-1.0)*r00*x1544))+(((-1.0)*npz*r00*x1543))+((npx*x1546))+((npx*x1547))+(((0.1625)*r00)))),IkReal(((((-1.0)*npz*r01*x1543))+((npy*r02*x1543))+((npy*x1547))+((npy*x1546))+(((-1.0)*r01*x1544))+(((0.1625)*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1549.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1548.value)))+(x1549.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1550=IKcos(j6);
IkReal x1551=IKsin(j6);
IkReal x1552=((0.64)*sj5);
IkReal x1553=((0.32)*sj5);
IkReal x1554=((0.32)*cj5);
IkReal x1555=(cj0*sj1);
IkReal x1556=(cj1*r20);
IkReal x1557=(cj1*r21);
IkReal x1558=(npy*x1551);
IkReal x1559=((0.33)*sj0*sj1);
IkReal x1560=((0.33)*x1551);
IkReal x1561=((0.33)*x1550);
IkReal x1562=(r10*x1550);
IkReal x1563=(r11*x1551);
IkReal x1564=((1.0)*x1550);
evalcond[0]=((0.0065)+((npx*x1550*x1552))+(((-0.64)*cj5*npz))+(((-1.0)*x1552*x1558))+(((-1.0)*pp)));
evalcond[1]=((((-1.0)*r22*x1554))+(((-1.0)*r21*x1551*x1553))+(((-1.0)*pz))+((r20*x1550*x1553))+(((-0.33)*cj1)));
evalcond[2]=((((-1.0)*r02*x1554))+(((-0.33)*x1555))+(((-1.0)*r01*x1551*x1553))+(((-1.0)*px))+((r00*x1550*x1553)));
evalcond[3]=(((x1553*x1562))+(((-1.0)*py))+(((-1.0)*x1553*x1563))+(((-1.0)*r12*x1554))+(((-1.0)*x1559)));
evalcond[4]=((((-1.0)*npx*x1551))+(((-1.0)*x1557*x1561))+(((-1.0)*x1556*x1560))+(((-1.0)*r00*x1555*x1560))+(((-1.0)*r01*x1555*x1561))+(((-1.0)*r11*x1550*x1559))+(((-1.0)*npy*x1564))+(((-1.0)*r10*x1551*x1559)));
evalcond[5]=((((-1.0)*x1559*x1562))+((r01*x1555*x1560))+(((-1.0)*x1556*x1561))+(((-1.0)*r00*x1555*x1561))+x1553+x1558+((x1557*x1560))+(((-1.0)*npx*x1564))+((x1559*x1563)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1565=((16.0)*npx);
IkReal x1566=(cj5*r22);
IkReal x1567=((16.5)*cj1);
IkReal x1568=((50.0)*pz);
IkReal x1569=((25.0)*pp);
IkReal x1570=((16.0)*npy);
IkReal x1571=((16.0)*cj5*npz);
CheckValue<IkReal> x1572=IKPowWithIntegerCheck(IKsign(((((-1.0)*r21*sj5*x1565))+((r20*sj5*x1570)))),-1);
if(!x1572.valid){
continue;
}
CheckValue<IkReal> x1573 = IKatan2WithCheck(IkReal((((npx*x1568))+((npx*x1567))+(((0.1625)*r20))+(((-1.0)*r20*x1569))+(((-1.0)*r20*x1571))+((x1565*x1566)))),IkReal(((((0.1625)*r21))+((x1566*x1570))+(((-1.0)*r21*x1571))+((npy*x1567))+((npy*x1568))+(((-1.0)*r21*x1569)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1573.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1572.value)))+(x1573.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1574=IKcos(j6);
IkReal x1575=IKsin(j6);
IkReal x1576=((0.64)*sj5);
IkReal x1577=((0.32)*sj5);
IkReal x1578=((0.32)*cj5);
IkReal x1579=(cj0*sj1);
IkReal x1580=(cj1*r20);
IkReal x1581=(cj1*r21);
IkReal x1582=(npy*x1575);
IkReal x1583=((0.33)*sj0*sj1);
IkReal x1584=((0.33)*x1575);
IkReal x1585=((0.33)*x1574);
IkReal x1586=(r10*x1574);
IkReal x1587=(r11*x1575);
IkReal x1588=((1.0)*x1574);
evalcond[0]=((0.0065)+(((-0.64)*cj5*npz))+((npx*x1574*x1576))+(((-1.0)*pp))+(((-1.0)*x1576*x1582)));
evalcond[1]=((((-1.0)*r22*x1578))+(((-1.0)*pz))+(((-1.0)*r21*x1575*x1577))+((r20*x1574*x1577))+(((-0.33)*cj1)));
evalcond[2]=((((-1.0)*r02*x1578))+(((-1.0)*r01*x1575*x1577))+((r00*x1574*x1577))+(((-0.33)*x1579))+(((-1.0)*px)));
evalcond[3]=((((-1.0)*x1583))+(((-1.0)*x1577*x1587))+(((-1.0)*py))+((x1577*x1586))+(((-1.0)*r12*x1578)));
evalcond[4]=((((-1.0)*x1580*x1584))+(((-1.0)*npx*x1575))+(((-1.0)*r10*x1575*x1583))+(((-1.0)*r00*x1579*x1584))+(((-1.0)*r01*x1579*x1585))+(((-1.0)*npy*x1588))+(((-1.0)*r11*x1574*x1583))+(((-1.0)*x1581*x1585)));
evalcond[5]=((((-1.0)*x1580*x1585))+(((-1.0)*r00*x1579*x1585))+((x1583*x1587))+x1577+x1582+(((-1.0)*npx*x1588))+((x1581*x1584))+(((-1.0)*x1583*x1586))+((r01*x1579*x1584)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1589=((8.0)*cj5);
IkReal x1590=((8.25)*cj1);
IkReal x1591=((8.25)*cj0*sj1);
CheckValue<IkReal> x1592=IKPowWithIntegerCheck(IKsign((r12*sj5)),-1);
if(!x1592.valid){
continue;
}
CheckValue<IkReal> x1593 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1589))+((r20*x1591))+(((-1.0)*r00*x1590))+(((25.0)*rxp0_1)))),IkReal(((((25.0)*rxp1_1))+(((-1.0)*r01*x1590))+((r21*x1591))+((r10*x1589)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1593.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((-1.5707963267949)*(x1592.value)))+(x1593.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1594=IKcos(j6);
IkReal x1595=IKsin(j6);
IkReal x1596=((0.64)*sj5);
IkReal x1597=((0.32)*sj5);
IkReal x1598=((0.32)*cj5);
IkReal x1599=(cj0*sj1);
IkReal x1600=(cj1*r20);
IkReal x1601=(cj1*r21);
IkReal x1602=(npy*x1595);
IkReal x1603=((0.33)*sj0*sj1);
IkReal x1604=((0.33)*x1595);
IkReal x1605=((0.33)*x1594);
IkReal x1606=(r10*x1594);
IkReal x1607=(r11*x1595);
IkReal x1608=((1.0)*x1594);
evalcond[0]=((0.0065)+(((-0.64)*cj5*npz))+((npx*x1594*x1596))+(((-1.0)*pp))+(((-1.0)*x1596*x1602)));
evalcond[1]=(((r20*x1594*x1597))+(((-1.0)*r21*x1595*x1597))+(((-1.0)*pz))+(((-1.0)*r22*x1598))+(((-0.33)*cj1)));
evalcond[2]=((((-1.0)*r02*x1598))+((r00*x1594*x1597))+(((-1.0)*px))+(((-1.0)*r01*x1595*x1597))+(((-0.33)*x1599)));
evalcond[3]=((((-1.0)*x1603))+(((-1.0)*py))+(((-1.0)*x1597*x1607))+(((-1.0)*r12*x1598))+((x1597*x1606)));
evalcond[4]=((((-1.0)*npy*x1608))+(((-1.0)*r10*x1595*x1603))+(((-1.0)*r11*x1594*x1603))+(((-1.0)*r01*x1599*x1605))+(((-1.0)*x1601*x1605))+(((-1.0)*x1600*x1604))+(((-1.0)*npx*x1595))+(((-1.0)*r00*x1599*x1604)));
evalcond[5]=(x1602+((x1601*x1604))+(((-1.0)*x1600*x1605))+x1597+((x1603*x1607))+(((-1.0)*x1603*x1606))+((r01*x1599*x1604))+(((-1.0)*r00*x1599*x1605))+(((-1.0)*npx*x1608)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x265=((1.0)*r12);
IkReal x266=((1.0)*cj5);
IkReal x267=(cj1*sj0);
IkReal x268=((1.0)*sj5);
IkReal x269=(cj0*r01);
IkReal x270=(sj0*sj1);
IkReal x271=((1.0)*cj1);
IkReal x272=(cj0*r00);
IkReal x273=((1.0)*sj0);
IkReal x274=((1.0)*sj6);
IkReal x275=(cj0*r02);
IkReal x276=((1.0)*sj1);
IkReal x277=((((-1.0)*r01*x273))+((cj0*r11)));
IkReal x278=((((-1.0)*r00*x273))+((cj0*r10)));
IkReal x279=(((r02*sj0))+(((-1.0)*cj0*x265)));
IkReal x280=(((cj1*x272))+((r10*x267))+(((-1.0)*r20*x276)));
IkReal x281=(((cj1*x269))+((r11*x267))+(((-1.0)*r21*x276)));
IkReal x282=(((cj1*r20))+((r10*x270))+((sj1*x272)));
IkReal x283=(((cj1*r21))+((r11*x270))+((sj1*x269)));
IkReal x284=((((-1.0)*x271*x275))+((r22*sj1))+(((-1.0)*x265*x267)));
IkReal x285=((((-1.0)*x274*x277))+((cj6*x278)));
IkReal x286=((((-1.0)*x265*x270))+(((-1.0)*r22*x271))+(((-1.0)*x275*x276)));
IkReal x287=((1.0)*x286);
IkReal x288=(((cj6*x280))+(((-1.0)*x274*x281)));
IkReal x289=(((cj6*x282))+(((-1.0)*x274*x283)));
new_r00=((((-1.0)*x268*x284))+((cj5*x288)));
new_r01=(((sj6*x280))+((cj6*x281)));
new_r02=((((-1.0)*x266*x284))+(((-1.0)*x268*x288)));
new_r10=((((-1.0)*x268*x279))+((cj5*x285)));
new_r11=(((sj6*x278))+((cj6*x277)));
new_r12=((((-1.0)*x268*x285))+(((-1.0)*x266*x279)));
new_r20=((((-1.0)*x268*x286))+((cj5*x289)));
new_r21=(((sj6*x282))+((cj6*x283)));
new_r22=((((-1.0)*x266*x286))+(((-1.0)*x268*x289)));
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
cj3array[0]=new_r22;
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j2eval[3];
j2eval[0]=sj3;
j2eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j2eval[2]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=new_r12;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j4mul = 1;
j4=0;
j2mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 4;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j4mul = 1;
j4=0;
j2mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 4;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x290=new_r22*new_r22;
IkReal x291=((16.0)*new_r10);
IkReal x292=((16.0)*new_r01);
IkReal x293=((16.0)*new_r22);
IkReal x294=((8.0)*new_r11);
IkReal x295=((8.0)*new_r00);
IkReal x296=(x290*x291);
IkReal x297=(x290*x292);
j2eval[0]=((IKabs((((new_r11*x293))+(((-32.0)*new_r00*x290))+(((16.0)*new_r00)))))+(IKabs((((x290*x294))+(((-1.0)*new_r22*x295)))))+(IKabs(((((-1.0)*x296))+x291)))+(IKabs(((((-1.0)*x292))+x297)))+(IKabs(((((-1.0)*x291))+x296)))+(IKabs(((((-1.0)*x295))+((new_r22*x294)))))+(IKabs(((((-1.0)*x297))+x292)))+(IKabs(((((32.0)*new_r11))+(((-16.0)*new_r11*x290))+(((-1.0)*new_r00*x293))))));
if( IKabs(j2eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j2, j4]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j2evalpoly[1];
IkReal x298=new_r22*new_r22;
IkReal x299=((16.0)*new_r10);
IkReal x300=(new_r11*new_r22);
IkReal x301=(x298*x299);
IkReal x302=((((8.0)*x300))+(((-8.0)*new_r00)));
op[0]=x302;
op[1]=(x299+(((-1.0)*x301)));
op[2]=((((16.0)*x300))+(((-32.0)*new_r00*x298))+(((16.0)*new_r00)));
op[3]=((((-1.0)*x299))+x301);
op[4]=x302;
polyroots4(op,zeror,numroots);
IkReal j2array[4], cj2array[4], sj2array[4], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[4]={true,true,true,true};
_nj2 = 4;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

IkReal x303=((16.0)*new_r01);
IkReal x304=new_r22*new_r22;
IkReal x305=(new_r00*new_r22);
IkReal x306=((8.0)*x305);
IkReal x307=(new_r11*x304);
IkReal x308=(x303*x304);
IkReal x309=((8.0)*x307);
j2evalpoly[0]=((((htj2*htj2)*(((((32.0)*new_r11))+(((-16.0)*x305))+(((-16.0)*x307))))))+x309+(((htj2*htj2*htj2)*((x308+(((-1.0)*x303))))))+((htj2*((x303+(((-1.0)*x308))))))+(((htj2*htj2*htj2*htj2)*((x309+(((-1.0)*x306))))))+(((-1.0)*x306)));
if( IKabs(j2evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal j4eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x310=cj2*cj2;
IkReal x311=(cj2*new_r22);
IkReal x312=((-1.0)+x310+(((-1.0)*x310*(new_r22*new_r22))));
j4eval[0]=x312;
j4eval[1]=((IKabs((((new_r01*x311))+((new_r00*sj2)))))+(IKabs(((((-1.0)*new_r00*x311))+((new_r01*sj2))))));
j4eval[2]=IKsign(x312);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=new_r22;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x313=new_r22*new_r22;
j4eval[0]=(((cj2*x313))+(((-1.0)*cj2)));
j4eval[1]=((((-1.0)*sj2))+((sj2*x313)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x314=IKsin(j4);
IkReal x315=IKcos(j4);
evalcond[0]=x314;
evalcond[1]=((-1.0)*x315);
evalcond[2]=((((-1.0)*x314))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x315))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x316=IKsin(j4);
IkReal x317=IKcos(j4);
evalcond[0]=x316;
evalcond[1]=((-1.0)*x317);
evalcond[2]=((((-1.0)*x316))+new_r00);
evalcond[3]=((((-1.0)*x317))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x318=IKsin(j4);
IkReal x319=IKcos(j4);
evalcond[0]=x318;
evalcond[1]=((-1.0)*x319);
evalcond[2]=((((-1.0)*x318))+new_r10);
evalcond[3]=((((-1.0)*x319))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x320=IKsin(j4);
IkReal x321=IKcos(j4);
evalcond[0]=x320;
evalcond[1]=((-1.0)*x321);
evalcond[2]=((((-1.0)*x320))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x321))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x322=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x322.valid){
continue;
}
if((x322.value) < -0.00001)
continue;
IkReal gconst50=((-1.0)*(IKsqrt(x322.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst50))+cj2)))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst50*gconst50))))) < -0.00001)
continue;
sj2=IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50)))));
cj2=gconst50;
if( (gconst50) < -1-IKFAST_SINCOS_THRESH || (gconst50) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=IKacos(gconst50);
CheckValue<IkReal> x323=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x323.valid){
continue;
}
if((x323.value) < -0.00001)
continue;
IkReal gconst50=((-1.0)*(IKsqrt(x323.value)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst50*gconst50))))) < -0.00001)
continue;
CheckValue<IkReal> x324=IKPowWithIntegerCheck(gconst50,-1);
if(!x324.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50))))))))+((gconst50*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x324.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50))))))))+((gconst50*new_r10))))+IKsqr((new_r11*(x324.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50))))))))+((gconst50*new_r10))), (new_r11*(x324.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x325=IKcos(j4);
IkReal x326=IKsin(j4);
IkReal x327=((1.0)*x325);
IkReal x328=((1.0)*x326);
if((((1.0)+(((-1.0)*(gconst50*gconst50))))) < -0.00001)
continue;
IkReal x329=IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50)))));
IkReal x330=((1.0)*x329);
evalcond[0]=x326;
evalcond[1]=((-1.0)*x325);
evalcond[2]=((((-1.0)*gconst50*x327))+new_r11);
evalcond[3]=((((-1.0)*gconst50*x328))+new_r10);
evalcond[4]=(((x325*x329))+new_r01);
evalcond[5]=(((x326*x329))+new_r00);
evalcond[6]=((((-1.0)*x328))+(((-1.0)*new_r00*x330))+((gconst50*new_r10)));
evalcond[7]=((((-1.0)*x327))+(((-1.0)*new_r01*x330))+((gconst50*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x331=IKPowWithIntegerCheck(IKsign(gconst50),-1);
if(!x331.valid){
continue;
}
CheckValue<IkReal> x332 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x332.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x331.value)))+(x332.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x333=IKcos(j4);
IkReal x334=IKsin(j4);
IkReal x335=((1.0)*x333);
IkReal x336=((1.0)*x334);
if((((1.0)+(((-1.0)*(gconst50*gconst50))))) < -0.00001)
continue;
IkReal x337=IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50)))));
IkReal x338=((1.0)*x337);
evalcond[0]=x334;
evalcond[1]=((-1.0)*x333);
evalcond[2]=((((-1.0)*gconst50*x335))+new_r11);
evalcond[3]=((((-1.0)*gconst50*x336))+new_r10);
evalcond[4]=(((x333*x337))+new_r01);
evalcond[5]=(((x334*x337))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x338))+(((-1.0)*x336))+((gconst50*new_r10)));
evalcond[7]=((((-1.0)*x335))+(((-1.0)*new_r01*x338))+((gconst50*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x339=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x339.valid){
continue;
}
if((x339.value) < -0.00001)
continue;
IkReal gconst50=((-1.0)*(IKsqrt(x339.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst50))+cj2)))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst50*gconst50))))) < -0.00001)
continue;
sj2=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50)))))));
cj2=gconst50;
if( (gconst50) < -1-IKFAST_SINCOS_THRESH || (gconst50) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=((-1.0)*(IKacos(gconst50)));
CheckValue<IkReal> x340=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x340.valid){
continue;
}
if((x340.value) < -0.00001)
continue;
IkReal gconst50=((-1.0)*(IKsqrt(x340.value)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst50*gconst50))))) < -0.00001)
continue;
CheckValue<IkReal> x341=IKPowWithIntegerCheck(gconst50,-1);
if(!x341.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50))))))))+((gconst50*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x341.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50))))))))+((gconst50*new_r10))))+IKsqr((new_r11*(x341.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50))))))))+((gconst50*new_r10))), (new_r11*(x341.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x342=IKcos(j4);
IkReal x343=IKsin(j4);
IkReal x344=((1.0)*x342);
IkReal x345=((1.0)*x343);
if((((1.0)+(((-1.0)*(gconst50*gconst50))))) < -0.00001)
continue;
IkReal x346=IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50)))));
evalcond[0]=x343;
evalcond[1]=((-1.0)*x342);
evalcond[2]=((((-1.0)*gconst50*x344))+new_r11);
evalcond[3]=((((-1.0)*gconst50*x345))+new_r10);
evalcond[4]=((((-1.0)*x344*x346))+new_r01);
evalcond[5]=((((-1.0)*x345*x346))+new_r00);
evalcond[6]=(((new_r00*x346))+(((-1.0)*x345))+((gconst50*new_r10)));
evalcond[7]=(((new_r01*x346))+(((-1.0)*x344))+((gconst50*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x347=IKPowWithIntegerCheck(IKsign(gconst50),-1);
if(!x347.valid){
continue;
}
CheckValue<IkReal> x348 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x348.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x347.value)))+(x348.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x349=IKcos(j4);
IkReal x350=IKsin(j4);
IkReal x351=((1.0)*x349);
IkReal x352=((1.0)*x350);
if((((1.0)+(((-1.0)*(gconst50*gconst50))))) < -0.00001)
continue;
IkReal x353=IKsqrt(((1.0)+(((-1.0)*(gconst50*gconst50)))));
evalcond[0]=x350;
evalcond[1]=((-1.0)*x349);
evalcond[2]=((((-1.0)*gconst50*x351))+new_r11);
evalcond[3]=((((-1.0)*gconst50*x352))+new_r10);
evalcond[4]=((((-1.0)*x351*x353))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x352*x353)));
evalcond[6]=((((-1.0)*x352))+((new_r00*x353))+((gconst50*new_r10)));
evalcond[7]=(((new_r01*x353))+(((-1.0)*x351))+((gconst50*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x354=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x354.valid){
continue;
}
if((x354.value) < -0.00001)
continue;
IkReal gconst51=IKsqrt(x354.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst51))+cj2)))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst51*gconst51))))) < -0.00001)
continue;
sj2=IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51)))));
cj2=gconst51;
if( (gconst51) < -1-IKFAST_SINCOS_THRESH || (gconst51) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=IKacos(gconst51);
CheckValue<IkReal> x355=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x355.valid){
continue;
}
if((x355.value) < -0.00001)
continue;
IkReal gconst51=IKsqrt(x355.value);
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst51*gconst51))))) < -0.00001)
continue;
CheckValue<IkReal> x356=IKPowWithIntegerCheck(gconst51,-1);
if(!x356.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51))))))))+((gconst51*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x356.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51))))))))+((gconst51*new_r10))))+IKsqr((new_r11*(x356.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51))))))))+((gconst51*new_r10))), (new_r11*(x356.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x357=IKcos(j4);
IkReal x358=IKsin(j4);
IkReal x359=((1.0)*x357);
IkReal x360=((1.0)*x358);
if((((1.0)+(((-1.0)*(gconst51*gconst51))))) < -0.00001)
continue;
IkReal x361=IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51)))));
IkReal x362=((1.0)*x361);
evalcond[0]=x358;
evalcond[1]=((-1.0)*x357);
evalcond[2]=((((-1.0)*gconst51*x359))+new_r11);
evalcond[3]=((((-1.0)*gconst51*x360))+new_r10);
evalcond[4]=(new_r01+((x357*x361)));
evalcond[5]=(((x358*x361))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x362))+(((-1.0)*x360))+((gconst51*new_r10)));
evalcond[7]=((((-1.0)*x359))+(((-1.0)*new_r01*x362))+((gconst51*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x363=IKPowWithIntegerCheck(IKsign(gconst51),-1);
if(!x363.valid){
continue;
}
CheckValue<IkReal> x364 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x364.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x363.value)))+(x364.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x365=IKcos(j4);
IkReal x366=IKsin(j4);
IkReal x367=((1.0)*x365);
IkReal x368=((1.0)*x366);
if((((1.0)+(((-1.0)*(gconst51*gconst51))))) < -0.00001)
continue;
IkReal x369=IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51)))));
IkReal x370=((1.0)*x369);
evalcond[0]=x366;
evalcond[1]=((-1.0)*x365);
evalcond[2]=((((-1.0)*gconst51*x367))+new_r11);
evalcond[3]=((((-1.0)*gconst51*x368))+new_r10);
evalcond[4]=(((x365*x369))+new_r01);
evalcond[5]=(((x366*x369))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x370))+(((-1.0)*x368))+((gconst51*new_r10)));
evalcond[7]=((((-1.0)*x367))+(((-1.0)*new_r01*x370))+((gconst51*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x371=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x371.valid){
continue;
}
if((x371.value) < -0.00001)
continue;
IkReal gconst51=IKsqrt(x371.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst51))+cj2)))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst51*gconst51))))) < -0.00001)
continue;
sj2=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51)))))));
cj2=gconst51;
if( (gconst51) < -1-IKFAST_SINCOS_THRESH || (gconst51) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=((-1.0)*(IKacos(gconst51)));
CheckValue<IkReal> x372=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x372.valid){
continue;
}
if((x372.value) < -0.00001)
continue;
IkReal gconst51=IKsqrt(x372.value);
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst51*gconst51))))) < -0.00001)
continue;
CheckValue<IkReal> x373=IKPowWithIntegerCheck(gconst51,-1);
if(!x373.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51))))))))+((gconst51*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x373.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51))))))))+((gconst51*new_r10))))+IKsqr((new_r11*(x373.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst51*gconst51))))))))+((gconst51*new_r10))), (new_r11*(x373.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x374=IKcos(j4);
IkReal x375=IKsin(j4);
IkReal x376=((1.0)*gconst51);
IkReal x377=((1.0)*x375);
IkReal x378=((1.0)*x374);
if((((1.0)+(((-1.0)*gconst51*x376)))) < -0.00001)
continue;
IkReal x379=IKsqrt(((1.0)+(((-1.0)*gconst51*x376))));
evalcond[0]=x375;
evalcond[1]=((-1.0)*x374);
evalcond[2]=((((-1.0)*x374*x376))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*x375*x376)));
evalcond[4]=((((-1.0)*x378*x379))+new_r01);
evalcond[5]=((((-1.0)*x377*x379))+new_r00);
evalcond[6]=((((-1.0)*x377))+((new_r00*x379))+((gconst51*new_r10)));
evalcond[7]=((((-1.0)*x378))+((new_r01*x379))+((gconst51*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x380=IKPowWithIntegerCheck(IKsign(gconst51),-1);
if(!x380.valid){
continue;
}
CheckValue<IkReal> x381 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x381.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x380.value)))+(x381.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x382=IKcos(j4);
IkReal x383=IKsin(j4);
IkReal x384=((1.0)*gconst51);
IkReal x385=((1.0)*x383);
IkReal x386=((1.0)*x382);
if((((1.0)+(((-1.0)*gconst51*x384)))) < -0.00001)
continue;
IkReal x387=IKsqrt(((1.0)+(((-1.0)*gconst51*x384))));
evalcond[0]=x383;
evalcond[1]=((-1.0)*x382);
evalcond[2]=(new_r11+(((-1.0)*x382*x384)));
evalcond[3]=(new_r10+(((-1.0)*x383*x384)));
evalcond[4]=((((-1.0)*x386*x387))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x385*x387)));
evalcond[6]=(((new_r00*x387))+(((-1.0)*x385))+((gconst51*new_r10)));
evalcond[7]=(((new_r01*x387))+(((-1.0)*x386))+((gconst51*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x388=new_r22*new_r22;
CheckValue<IkReal> x389=IKPowWithIntegerCheck((((cj2*x388))+(((-1.0)*cj2))),-1);
if(!x389.valid){
continue;
}
CheckValue<IkReal> x390=IKPowWithIntegerCheck(((((-1.0)*sj2))+((sj2*x388))),-1);
if(!x390.valid){
continue;
}
if( IKabs(((x389.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x390.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x389.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x390.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x389.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x390.value)*((((new_r10*new_r22))+new_r01))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x391=IKsin(j4);
IkReal x392=IKcos(j4);
IkReal x393=(cj2*new_r01);
IkReal x394=(new_r10*sj2);
IkReal x395=((1.0)*sj2);
IkReal x396=(cj2*new_r00);
IkReal x397=(new_r22*sj2);
IkReal x398=((1.0)*x392);
IkReal x399=(new_r22*x391);
IkReal x400=((1.0)*x391);
evalcond[0]=(((new_r11*sj2))+x393+x399);
evalcond[1]=(((new_r11*x397))+x391+((new_r22*x393)));
evalcond[2]=(((cj2*new_r10))+(((-1.0)*new_r00*x395))+(((-1.0)*x400)));
evalcond[3]=((((-1.0)*new_r01*x395))+(((-1.0)*x398))+((cj2*new_r11)));
evalcond[4]=(((sj2*x392))+((cj2*x399))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x398))+x394+x396);
evalcond[6]=((((-1.0)*cj2*new_r22*x398))+((sj2*x391))+new_r00);
evalcond[7]=(((x391*x397))+(((-1.0)*cj2*x398))+new_r11);
evalcond[8]=((((-1.0)*x398))+((new_r22*x396))+((new_r22*x394)));
evalcond[9]=((((-1.0)*cj2*x400))+new_r10+(((-1.0)*new_r22*x392*x395)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x401=((1.0)*new_r01);
CheckValue<IkReal> x402=IKPowWithIntegerCheck(new_r22,-1);
if(!x402.valid){
continue;
}
if( IKabs(((x402.value)*(((((-1.0)*cj2*x401))+(((-1.0)*new_r11*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*new_r11))+(((-1.0)*sj2*x401)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x402.value)*(((((-1.0)*cj2*x401))+(((-1.0)*new_r11*sj2))))))+IKsqr((((cj2*new_r11))+(((-1.0)*sj2*x401))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x402.value)*(((((-1.0)*cj2*x401))+(((-1.0)*new_r11*sj2))))), (((cj2*new_r11))+(((-1.0)*sj2*x401))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x403=IKsin(j4);
IkReal x404=IKcos(j4);
IkReal x405=(cj2*new_r01);
IkReal x406=(new_r10*sj2);
IkReal x407=((1.0)*sj2);
IkReal x408=(cj2*new_r00);
IkReal x409=(new_r22*sj2);
IkReal x410=((1.0)*x404);
IkReal x411=(new_r22*x403);
IkReal x412=((1.0)*x403);
evalcond[0]=(((new_r11*sj2))+x405+x411);
evalcond[1]=(((new_r22*x405))+x403+((new_r11*x409)));
evalcond[2]=(((cj2*new_r10))+(((-1.0)*new_r00*x407))+(((-1.0)*x412)));
evalcond[3]=(((cj2*new_r11))+(((-1.0)*x410))+(((-1.0)*new_r01*x407)));
evalcond[4]=(((sj2*x404))+new_r01+((cj2*x411)));
evalcond[5]=(x406+x408+(((-1.0)*new_r22*x410)));
evalcond[6]=((((-1.0)*cj2*new_r22*x410))+((sj2*x403))+new_r00);
evalcond[7]=((((-1.0)*cj2*x410))+new_r11+((x403*x409)));
evalcond[8]=(((new_r22*x408))+((new_r22*x406))+(((-1.0)*x410)));
evalcond[9]=((((-1.0)*cj2*x412))+new_r10+(((-1.0)*new_r22*x404*x407)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x413=cj2*cj2;
IkReal x414=(cj2*new_r22);
CheckValue<IkReal> x415 = IKatan2WithCheck(IkReal((((new_r00*sj2))+((new_r01*x414)))),IkReal(((((-1.0)*new_r00*x414))+((new_r01*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x415.valid){
continue;
}
CheckValue<IkReal> x416=IKPowWithIntegerCheck(IKsign(((-1.0)+x413+(((-1.0)*x413*(new_r22*new_r22))))),-1);
if(!x416.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x415.value)+(((1.5707963267949)*(x416.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x417=IKsin(j4);
IkReal x418=IKcos(j4);
IkReal x419=(cj2*new_r01);
IkReal x420=(new_r10*sj2);
IkReal x421=((1.0)*sj2);
IkReal x422=(cj2*new_r00);
IkReal x423=(new_r22*sj2);
IkReal x424=((1.0)*x418);
IkReal x425=(new_r22*x417);
IkReal x426=((1.0)*x417);
evalcond[0]=(((new_r11*sj2))+x419+x425);
evalcond[1]=(((new_r22*x419))+((new_r11*x423))+x417);
evalcond[2]=((((-1.0)*new_r00*x421))+(((-1.0)*x426))+((cj2*new_r10)));
evalcond[3]=((((-1.0)*x424))+((cj2*new_r11))+(((-1.0)*new_r01*x421)));
evalcond[4]=(((sj2*x418))+((cj2*x425))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x424))+x422+x420);
evalcond[6]=((((-1.0)*cj2*new_r22*x424))+((sj2*x417))+new_r00);
evalcond[7]=((((-1.0)*cj2*x424))+new_r11+((x417*x423)));
evalcond[8]=(((new_r22*x420))+((new_r22*x422))+(((-1.0)*x424)));
evalcond[9]=((((-1.0)*cj2*x426))+(((-1.0)*new_r22*x418*x421))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x428=IKPowWithIntegerCheck(sj3,-1);
if(!x428.valid){
continue;
}
IkReal x427=x428.value;
CheckValue<IkReal> x429=IKPowWithIntegerCheck(new_r12,-1);
if(!x429.valid){
continue;
}
if( IKabs((x427*(x429.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x427)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x427*(x429.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3)))))))+IKsqr((new_r02*x427))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x427*(x429.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3)))))), (new_r02*x427));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x430=IKcos(j2);
IkReal x431=IKsin(j2);
IkReal x432=((1.0)*sj3);
IkReal x433=((1.0)*cj3);
IkReal x434=(new_r02*x430);
IkReal x435=(new_r12*x431);
IkReal x436=(x431*x432);
evalcond[0]=((((-1.0)*x430*x432))+new_r02);
evalcond[1]=((((-1.0)*x436))+new_r12);
evalcond[2]=(((new_r12*x430))+(((-1.0)*new_r02*x431)));
evalcond[3]=((((-1.0)*x432))+x434+x435);
evalcond[4]=(((cj3*x434))+((cj3*x435))+(((-1.0)*new_r22*x432)));
evalcond[5]=((((-1.0)*new_r00*x430*x432))+(((-1.0)*new_r10*x436))+(((-1.0)*new_r20*x433)));
evalcond[6]=((((-1.0)*new_r01*x430*x432))+(((-1.0)*new_r11*x436))+(((-1.0)*new_r21*x433)));
evalcond[7]=((1.0)+(((-1.0)*x432*x434))+(((-1.0)*x432*x435))+(((-1.0)*new_r22*x433)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj2;
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=cj2;
j4eval[1]=cj3;
j4eval[2]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=cj3;
j4eval[1]=IKsign(cj3);
j4eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x437=IKsin(j4);
IkReal x438=((1.0)*(IKcos(j4)));
evalcond[0]=(x437+new_r11);
evalcond[1]=((((-1.0)*x438))+new_r10);
evalcond[2]=((((-1.0)*x437))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x438))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x439=IKcos(j4);
IkReal x440=((1.0)*(IKsin(j4)));
evalcond[0]=(x439+new_r10);
evalcond[1]=((((-1.0)*x440))+new_r11);
evalcond[2]=((((-1.0)*x440))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x439))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x441=IKcos(j4);
IkReal x442=((1.0)*(IKsin(j4)));
evalcond[0]=(x441+new_r20);
evalcond[1]=((((-1.0)*x442))+new_r21);
evalcond[2]=((((-1.0)*x442))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x441))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x443=IKsin(j4);
IkReal x444=((1.0)*(IKcos(j4)));
evalcond[0]=(x443+new_r21);
evalcond[1]=((((-1.0)*x444))+new_r20);
evalcond[2]=((((-1.0)*x443))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x444))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x445=IKsin(j4);
IkReal x446=IKcos(j4);
IkReal x447=((-1.0)*x446);
evalcond[0]=x445;
evalcond[1]=(new_r22*x445);
evalcond[2]=x447;
evalcond[3]=(new_r22*x447);
evalcond[4]=((((-1.0)*x445))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x446))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x448=IKPowWithIntegerCheck(sj3,-1);
if(!x448.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x448.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x448.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x448.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x449=IKsin(j4);
IkReal x450=IKcos(j4);
IkReal x451=((1.0)*sj3);
IkReal x452=((1.0)*x450);
evalcond[0]=(((sj3*x450))+new_r20);
evalcond[1]=(((cj3*x449))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x449*x451)));
evalcond[3]=(new_r10+(((-1.0)*cj3*x452)));
evalcond[4]=((((-1.0)*x449))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x452))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x451))+x449+((cj3*new_r11)));
evalcond[7]=((((-1.0)*new_r20*x451))+(((-1.0)*x452))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x453=IKPowWithIntegerCheck(IKsign(cj3),-1);
if(!x453.valid){
continue;
}
CheckValue<IkReal> x454 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x454.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x453.value)))+(x454.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x455=IKsin(j4);
IkReal x456=IKcos(j4);
IkReal x457=((1.0)*sj3);
IkReal x458=((1.0)*x456);
evalcond[0]=(((sj3*x456))+new_r20);
evalcond[1]=(((cj3*x455))+new_r11);
evalcond[2]=((((-1.0)*x455*x457))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj3*x458)));
evalcond[4]=((((-1.0)*x455))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x458))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x457))+x455+((cj3*new_r11)));
evalcond[7]=((((-1.0)*new_r20*x457))+(((-1.0)*x458))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x459=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x459.valid){
continue;
}
CheckValue<IkReal> x460 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x460.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x459.value)))+(x460.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x461=IKsin(j4);
IkReal x462=IKcos(j4);
IkReal x463=((1.0)*sj3);
IkReal x464=((1.0)*x462);
evalcond[0]=(((sj3*x462))+new_r20);
evalcond[1]=(((cj3*x461))+new_r11);
evalcond[2]=((((-1.0)*x461*x463))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj3*x464)));
evalcond[4]=((((-1.0)*x461))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x464))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x463))+x461+((cj3*new_r11)));
evalcond[7]=((((-1.0)*new_r20*x463))+(((-1.0)*x464))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x465=IKcos(j4);
IkReal x466=IKsin(j4);
IkReal x467=((1.0)*sj3);
IkReal x468=((1.0)*new_r11);
IkReal x469=((1.0)*new_r10);
IkReal x470=((1.0)*x465);
evalcond[0]=(((sj3*x465))+new_r20);
evalcond[1]=((((-1.0)*x466))+new_r00);
evalcond[2]=((((-1.0)*x470))+new_r01);
evalcond[3]=((((-1.0)*x466*x467))+new_r21);
evalcond[4]=((((-1.0)*x468))+((cj3*x466)));
evalcond[5]=((((-1.0)*x469))+(((-1.0)*cj3*x470)));
evalcond[6]=((((-1.0)*new_r21*x467))+x466+(((-1.0)*cj3*x468)));
evalcond[7]=((((-1.0)*new_r20*x467))+(((-1.0)*x470))+(((-1.0)*cj3*x469)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x471=IKcos(j4);
IkReal x472=IKsin(j4);
IkReal x473=((1.0)*sj2);
IkReal x474=((1.0)*cj2);
IkReal x475=((1.0)*x472);
evalcond[0]=(x471+new_r20);
evalcond[1]=((((-1.0)*x475))+new_r21);
evalcond[2]=(new_r01+((sj2*x471)));
evalcond[3]=(new_r00+((sj2*x472)));
evalcond[4]=((((-1.0)*x471*x474))+new_r11);
evalcond[5]=((((-1.0)*x472*x474))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x473))+(((-1.0)*x475))+((cj2*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x473))+(((-1.0)*x471))+((cj2*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x476=IKcos(j4);
IkReal x477=IKsin(j4);
IkReal x478=((1.0)*sj2);
IkReal x479=((1.0)*x476);
IkReal x480=((1.0)*x477);
evalcond[0]=(x477+new_r21);
evalcond[1]=((((-1.0)*x479))+new_r20);
evalcond[2]=(new_r01+((sj2*x476)));
evalcond[3]=(new_r00+((sj2*x477)));
evalcond[4]=(new_r11+(((-1.0)*cj2*x479)));
evalcond[5]=((((-1.0)*cj2*x480))+new_r10);
evalcond[6]=((((-1.0)*x480))+(((-1.0)*new_r00*x478))+((cj2*new_r10)));
evalcond[7]=((((-1.0)*x479))+(((-1.0)*new_r01*x478))+((cj2*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x481=((1.0)*sj2);
if( IKabs(((((-1.0)*new_r00*x481))+(((-1.0)*cj2*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x481))+((cj2*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x481))+(((-1.0)*cj2*new_r01))))+IKsqr(((((-1.0)*new_r01*x481))+((cj2*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r00*x481))+(((-1.0)*cj2*new_r01))), ((((-1.0)*new_r01*x481))+((cj2*new_r00))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x482=IKsin(j4);
IkReal x483=IKcos(j4);
IkReal x484=((1.0)*sj2);
IkReal x485=((1.0)*x483);
IkReal x486=(sj2*x482);
IkReal x487=(cj2*x482);
IkReal x488=(cj2*x485);
evalcond[0]=(((new_r11*sj2))+x482+((cj2*new_r01)));
evalcond[1]=(x487+((sj2*x483))+new_r01);
evalcond[2]=(((new_r10*sj2))+(((-1.0)*x485))+((cj2*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x484))+(((-1.0)*x482))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x484))+(((-1.0)*x485))+((cj2*new_r11)));
evalcond[5]=((((-1.0)*x488))+x486+new_r00);
evalcond[6]=((((-1.0)*x488))+x486+new_r11);
evalcond[7]=((((-1.0)*x483*x484))+(((-1.0)*x487))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x489=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj2*x489))+((cj2*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x489)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj2*x489))+((cj2*new_r01))))+IKsqr(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x489))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*sj2*x489))+((cj2*new_r01))), ((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x489))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x490=IKcos(j4);
IkReal x491=IKsin(j4);
IkReal x492=((1.0)*sj2);
IkReal x493=((1.0)*cj2);
IkReal x494=((1.0)*x491);
IkReal x495=(sj2*x490);
IkReal x496=(x491*x493);
evalcond[0]=(((new_r10*sj2))+x490+((cj2*new_r00)));
evalcond[1]=((((-1.0)*x494))+((new_r11*sj2))+((cj2*new_r01)));
evalcond[2]=(((sj2*x491))+new_r00+((cj2*x490)));
evalcond[3]=((((-1.0)*new_r00*x492))+(((-1.0)*x494))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x492))+(((-1.0)*x490))+((cj2*new_r11)));
evalcond[5]=((((-1.0)*x496))+x495+new_r01);
evalcond[6]=((((-1.0)*x496))+x495+new_r10);
evalcond[7]=((((-1.0)*x491*x492))+(((-1.0)*x490*x493))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x497=IKcos(j4);
IkReal x498=IKsin(j4);
IkReal x499=((1.0)*sj3);
IkReal x500=((1.0)*x497);
evalcond[0]=(((sj3*x497))+new_r20);
evalcond[1]=((((-1.0)*x498))+new_r10);
evalcond[2]=((((-1.0)*x500))+new_r11);
evalcond[3]=(new_r01+((cj3*x498)));
evalcond[4]=((((-1.0)*x498*x499))+new_r21);
evalcond[5]=((((-1.0)*cj3*x500))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x499))+x498+((cj3*new_r01)));
evalcond[7]=((((-1.0)*new_r20*x499))+(((-1.0)*x500))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=cj3;
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x501=IKcos(j4);
IkReal x502=((1.0)*(IKsin(j4)));
evalcond[0]=(x501+new_r20);
evalcond[1]=((((-1.0)*x502))+new_r21);
evalcond[2]=((((-1.0)*x502))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x501)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x503=IKsin(j4);
IkReal x504=((1.0)*(IKcos(j4)));
evalcond[0]=(x503+new_r21);
evalcond[1]=((((-1.0)*x504))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x503)));
evalcond[3]=((((-1.0)*x504))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x505=IKsin(j4);
IkReal x506=((1.0)*(IKcos(j4)));
evalcond[0]=(x505+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x505)));
evalcond[2]=((((-1.0)*x506))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x506))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x507=IKcos(j4);
IkReal x508=((1.0)*(IKsin(j4)));
evalcond[0]=(x507+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x508))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x507)));
evalcond[3]=((((-1.0)*x508))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x509=IKsin(j4);
IkReal x510=IKcos(j4);
IkReal x511=((-1.0)*x510);
evalcond[0]=x509;
evalcond[1]=(new_r22*x509);
evalcond[2]=x511;
evalcond[3]=(new_r22*x511);
evalcond[4]=((((-1.0)*new_r10))+(((-1.0)*x509)));
evalcond[5]=((((-1.0)*x510))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x512=IKPowWithIntegerCheck(cj3,-1);
if(!x512.valid){
continue;
}
CheckValue<IkReal> x513=IKPowWithIntegerCheck(sj3,-1);
if(!x513.valid){
continue;
}
if( IKabs((new_r01*(x512.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x513.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x512.value)))+IKsqr(((-1.0)*new_r20*(x513.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r01*(x512.value)), ((-1.0)*new_r20*(x513.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x514=IKsin(j4);
IkReal x515=IKcos(j4);
IkReal x516=((1.0)*new_r00);
IkReal x517=((1.0)*sj3);
IkReal x518=((1.0)*new_r01);
IkReal x519=((1.0)*x515);
evalcond[0]=(((sj3*x515))+new_r20);
evalcond[1]=((((-1.0)*x514*x517))+new_r21);
evalcond[2]=((((-1.0)*x514))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x519)));
evalcond[4]=(((cj3*x514))+(((-1.0)*x518)));
evalcond[5]=((((-1.0)*cj3*x519))+(((-1.0)*x516)));
evalcond[6]=((((-1.0)*cj3*x518))+x514+(((-1.0)*new_r21*x517)));
evalcond[7]=((((-1.0)*cj3*x516))+(((-1.0)*new_r20*x517))+(((-1.0)*x519)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x520=IKPowWithIntegerCheck(sj3,-1);
if(!x520.valid){
continue;
}
if( IKabs((new_r21*(x520.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x520.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r21*(x520.value)), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x521=IKsin(j4);
IkReal x522=IKcos(j4);
IkReal x523=((1.0)*new_r00);
IkReal x524=((1.0)*sj3);
IkReal x525=((1.0)*new_r01);
IkReal x526=((1.0)*x522);
evalcond[0]=(((sj3*x522))+new_r20);
evalcond[1]=((((-1.0)*x521*x524))+new_r21);
evalcond[2]=((((-1.0)*x521))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x526))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x525))+((cj3*x521)));
evalcond[5]=((((-1.0)*cj3*x526))+(((-1.0)*x523)));
evalcond[6]=((((-1.0)*cj3*x525))+(((-1.0)*new_r21*x524))+x521);
evalcond[7]=((((-1.0)*cj3*x523))+(((-1.0)*new_r20*x524))+(((-1.0)*x526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x527=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x527.valid){
continue;
}
CheckValue<IkReal> x528 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x528.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x527.value)))+(x528.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x529=IKsin(j4);
IkReal x530=IKcos(j4);
IkReal x531=((1.0)*new_r00);
IkReal x532=((1.0)*sj3);
IkReal x533=((1.0)*new_r01);
IkReal x534=((1.0)*x530);
evalcond[0]=(((sj3*x530))+new_r20);
evalcond[1]=((((-1.0)*x529*x532))+new_r21);
evalcond[2]=((((-1.0)*x529))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x534))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x533))+((cj3*x529)));
evalcond[5]=((((-1.0)*cj3*x534))+(((-1.0)*x531)));
evalcond[6]=((((-1.0)*cj3*x533))+(((-1.0)*new_r21*x532))+x529);
evalcond[7]=((((-1.0)*cj3*x531))+(((-1.0)*x534))+(((-1.0)*new_r20*x532)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j4eval[0]=IKabs(new_r22);
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j4array[2], cj4array[2], sj4array[2], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[2]={true,true};
_nj4 = 2;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x536=IKPowWithIntegerCheck(sj3,-1);
if(!x536.valid){
continue;
}
IkReal x535=x536.value;
CheckValue<IkReal> x537=IKPowWithIntegerCheck(cj2,-1);
if(!x537.valid){
continue;
}
CheckValue<IkReal> x538=IKPowWithIntegerCheck(cj3,-1);
if(!x538.valid){
continue;
}
if( IKabs((x535*(x537.value)*(x538.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x535)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x535*(x537.value)*(x538.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3))))))+IKsqr(((-1.0)*new_r20*x535))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x535*(x537.value)*(x538.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3))))), ((-1.0)*new_r20*x535));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x539=IKsin(j4);
IkReal x540=IKcos(j4);
IkReal x541=(cj2*new_r01);
IkReal x542=(new_r10*sj2);
IkReal x543=((1.0)*sj3);
IkReal x544=((1.0)*sj2);
IkReal x545=(new_r11*sj2);
IkReal x546=(cj2*new_r00);
IkReal x547=((1.0)*x540);
IkReal x548=(sj2*x539);
IkReal x549=(cj2*x539);
evalcond[0]=(((sj3*x540))+new_r20);
evalcond[1]=((((-1.0)*x539*x543))+new_r21);
evalcond[2]=(x545+x541+((cj3*x539)));
evalcond[3]=((((-1.0)*x539))+(((-1.0)*new_r00*x544))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x544))+(((-1.0)*x547))+((cj2*new_r11)));
evalcond[5]=(((sj2*x540))+((cj3*x549))+new_r01);
evalcond[6]=((((-1.0)*cj3*x547))+x546+x542);
evalcond[7]=((((-1.0)*cj2*cj3*x547))+x548+new_r00);
evalcond[8]=((((-1.0)*cj2*x547))+((cj3*x548))+new_r11);
evalcond[9]=((((-1.0)*x549))+(((-1.0)*cj3*x540*x544))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x543))+x539+((cj3*x545))+((cj3*x541)));
evalcond[11]=((((-1.0)*new_r20*x543))+(((-1.0)*x547))+((cj3*x546))+((cj3*x542)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x551=IKPowWithIntegerCheck(sj3,-1);
if(!x551.valid){
continue;
}
IkReal x550=x551.value;
CheckValue<IkReal> x552=IKPowWithIntegerCheck(sj2,-1);
if(!x552.valid){
continue;
}
if( IKabs((x550*(x552.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x550)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x550*(x552.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3))))))+IKsqr(((-1.0)*new_r20*x550))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x550*(x552.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3))))), ((-1.0)*new_r20*x550));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x553=IKsin(j4);
IkReal x554=IKcos(j4);
IkReal x555=(cj2*new_r01);
IkReal x556=(new_r10*sj2);
IkReal x557=((1.0)*sj3);
IkReal x558=((1.0)*sj2);
IkReal x559=(new_r11*sj2);
IkReal x560=(cj2*new_r00);
IkReal x561=((1.0)*x554);
IkReal x562=(sj2*x553);
IkReal x563=(cj2*x553);
evalcond[0]=(((sj3*x554))+new_r20);
evalcond[1]=((((-1.0)*x553*x557))+new_r21);
evalcond[2]=(x559+x555+((cj3*x553)));
evalcond[3]=((((-1.0)*x553))+(((-1.0)*new_r00*x558))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x558))+((cj2*new_r11))+(((-1.0)*x561)));
evalcond[5]=(((cj3*x563))+((sj2*x554))+new_r01);
evalcond[6]=((((-1.0)*cj3*x561))+x556+x560);
evalcond[7]=(x562+new_r00+(((-1.0)*cj2*cj3*x561)));
evalcond[8]=(((cj3*x562))+new_r11+(((-1.0)*cj2*x561)));
evalcond[9]=((((-1.0)*cj3*x554*x558))+(((-1.0)*x563))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x557))+x553+((cj3*x559))+((cj3*x555)));
evalcond[11]=(((cj3*x560))+(((-1.0)*new_r20*x557))+((cj3*x556))+(((-1.0)*x561)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x564=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x564.valid){
continue;
}
CheckValue<IkReal> x565 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x565.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x564.value)))+(x565.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x566=IKsin(j4);
IkReal x567=IKcos(j4);
IkReal x568=(cj2*new_r01);
IkReal x569=(new_r10*sj2);
IkReal x570=((1.0)*sj3);
IkReal x571=((1.0)*sj2);
IkReal x572=(new_r11*sj2);
IkReal x573=(cj2*new_r00);
IkReal x574=((1.0)*x567);
IkReal x575=(sj2*x566);
IkReal x576=(cj2*x566);
evalcond[0]=(((sj3*x567))+new_r20);
evalcond[1]=((((-1.0)*x566*x570))+new_r21);
evalcond[2]=(((cj3*x566))+x572+x568);
evalcond[3]=((((-1.0)*x566))+(((-1.0)*new_r00*x571))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*x574))+((cj2*new_r11))+(((-1.0)*new_r01*x571)));
evalcond[5]=(((cj3*x576))+new_r01+((sj2*x567)));
evalcond[6]=((((-1.0)*cj3*x574))+x573+x569);
evalcond[7]=((((-1.0)*cj2*cj3*x574))+x575+new_r00);
evalcond[8]=((((-1.0)*cj2*x574))+((cj3*x575))+new_r11);
evalcond[9]=((((-1.0)*cj3*x567*x571))+(((-1.0)*x576))+new_r10);
evalcond[10]=(((cj3*x568))+((cj3*x572))+x566+(((-1.0)*new_r21*x570)));
evalcond[11]=(((cj3*x569))+((cj3*x573))+(((-1.0)*x574))+(((-1.0)*new_r20*x570)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x577=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x577.valid){
continue;
}
CheckValue<IkReal> x578 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x578.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x577.value)))+(x578.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((sj3*(IKcos(j4))))+new_r20);
evalcond[1]=((((-1.0)*sj3*(IKsin(j4))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj3;
j2eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j2eval[2]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=cj4;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x579=IKsin(j2);
IkReal x580=IKcos(j2);
IkReal x581=((1.0)*sj3);
IkReal x582=(new_r02*x580);
IkReal x583=(new_r22*x579);
IkReal x584=(new_r01*x580);
IkReal x585=(new_r22*x580);
IkReal x586=(new_r11*x579);
IkReal x587=(new_r12*x579);
IkReal x588=((1.0)*x579);
IkReal x589=(new_r10*x579);
IkReal x590=(new_r00*x580);
evalcond[0]=(x579+new_r00);
evalcond[1]=(x585+new_r01);
evalcond[2]=(x583+new_r11);
evalcond[3]=((((-1.0)*x580))+new_r10);
evalcond[4]=((((-1.0)*x580*x581))+new_r02);
evalcond[5]=((((-1.0)*x579*x581))+new_r12);
evalcond[6]=(x589+x590);
evalcond[7]=(((new_r12*x580))+(((-1.0)*new_r02*x588)));
evalcond[8]=((((-1.0)*new_r01*x588))+((new_r11*x580)));
evalcond[9]=(x584+x586+new_r22);
evalcond[10]=((-1.0)+(((-1.0)*new_r00*x588))+((new_r10*x580)));
evalcond[11]=(((new_r00*x585))+((new_r10*x583)));
evalcond[12]=(x582+x587+(((-1.0)*x581)));
evalcond[13]=((((-1.0)*x581*x590))+(((-1.0)*x581*x589)));
evalcond[14]=((((-1.0)*new_r22*x581))+((new_r22*x582))+((new_r12*x583)));
evalcond[15]=((((-1.0)*cj3*new_r21))+(((-1.0)*x581*x584))+(((-1.0)*x581*x586)));
evalcond[16]=((1.0)+(((-1.0)*sj3*x581))+((new_r22*x584))+((new_r11*x583)));
evalcond[17]=((1.0)+(((-1.0)*(new_r22*new_r22)))+(((-1.0)*x581*x582))+(((-1.0)*x581*x587)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x591=IKcos(j2);
IkReal x592=IKsin(j2);
IkReal x593=((1.0)*sj3);
IkReal x594=((1.0)*new_r22);
IkReal x595=(new_r02*x591);
IkReal x596=(new_r01*x591);
IkReal x597=(new_r00*x591);
IkReal x598=(new_r22*x592);
IkReal x599=(new_r12*x592);
IkReal x600=((1.0)*x592);
IkReal x601=(new_r11*x592);
IkReal x602=(new_r10*x592);
evalcond[0]=(x591+new_r10);
evalcond[1]=((((-1.0)*x600))+new_r00);
evalcond[2]=(new_r02+(((-1.0)*x591*x593)));
evalcond[3]=((((-1.0)*x592*x593))+new_r12);
evalcond[4]=(new_r01+(((-1.0)*x591*x594)));
evalcond[5]=((((-1.0)*x592*x594))+new_r11);
evalcond[6]=(x597+x602);
evalcond[7]=(((new_r12*x591))+(((-1.0)*new_r02*x600)));
evalcond[8]=(((new_r11*x591))+(((-1.0)*new_r01*x600)));
evalcond[9]=((1.0)+((new_r10*x591))+(((-1.0)*new_r00*x600)));
evalcond[10]=(((new_r10*x598))+((new_r22*x597)));
evalcond[11]=((((-1.0)*x593))+x595+x599);
evalcond[12]=((((-1.0)*x594))+x596+x601);
evalcond[13]=((((-1.0)*x593*x602))+(((-1.0)*x593*x597)));
evalcond[14]=(((new_r12*x598))+(((-1.0)*new_r22*x593))+((new_r22*x595)));
evalcond[15]=((-1.0)+(sj3*sj3)+((new_r11*x598))+((new_r22*x596)));
evalcond[16]=((((-1.0)*x593*x601))+((new_r22*sj3))+(((-1.0)*x593*x596)));
evalcond[17]=((1.0)+(((-1.0)*x593*x599))+(((-1.0)*x593*x595))+(((-1.0)*new_r22*x594)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x603=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x603))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x603)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x603))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x603))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj4*x603))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x603))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x604=IKsin(j2);
IkReal x605=IKcos(j2);
IkReal x606=((1.0)*cj4);
IkReal x607=(sj4*x604);
IkReal x608=(sj4*x605);
IkReal x609=((1.0)*x604);
IkReal x610=(x605*x606);
evalcond[0]=(sj4+((new_r11*x604))+((new_r01*x605)));
evalcond[1]=(x608+new_r01+((cj4*x604)));
evalcond[2]=((((-1.0)*x610))+x607+new_r00);
evalcond[3]=((((-1.0)*x610))+x607+new_r11);
evalcond[4]=(((new_r10*x604))+((new_r00*x605))+(((-1.0)*x606)));
evalcond[5]=((((-1.0)*x604*x606))+(((-1.0)*x608))+new_r10);
evalcond[6]=((((-1.0)*sj4))+((new_r10*x605))+(((-1.0)*new_r00*x609)));
evalcond[7]=(((new_r11*x605))+(((-1.0)*x606))+(((-1.0)*new_r01*x609)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x611=((1.0)*cj4);
if( IKabs(((((-1.0)*new_r00*sj4))+(((-1.0)*new_r01*x611)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj4))+(((-1.0)*new_r00*x611)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj4))+(((-1.0)*new_r01*x611))))+IKsqr((((new_r01*sj4))+(((-1.0)*new_r00*x611))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r00*sj4))+(((-1.0)*new_r01*x611))), (((new_r01*sj4))+(((-1.0)*new_r00*x611))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x612=IKsin(j2);
IkReal x613=IKcos(j2);
IkReal x614=((1.0)*sj4);
IkReal x615=(cj4*x612);
IkReal x616=((1.0)*x613);
IkReal x617=((1.0)*x612);
IkReal x618=(x613*x614);
evalcond[0]=(cj4+((new_r10*x612))+((new_r00*x613)));
evalcond[1]=(((sj4*x612))+new_r00+((cj4*x613)));
evalcond[2]=((((-1.0)*x618))+x615+new_r01);
evalcond[3]=((((-1.0)*x618))+x615+new_r10);
evalcond[4]=(((new_r11*x612))+(((-1.0)*x614))+((new_r01*x613)));
evalcond[5]=((((-1.0)*x612*x614))+(((-1.0)*cj4*x616))+new_r11);
evalcond[6]=(((new_r10*x613))+(((-1.0)*x614))+(((-1.0)*new_r00*x617)));
evalcond[7]=(((new_r11*x613))+(((-1.0)*new_r01*x617))+(((-1.0)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x620 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x620.valid){
continue;
}
IkReal x619=x620.value;
j2array[0]=((-1.0)*x619);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x619)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x621=IKcos(j2);
IkReal x622=IKsin(j2);
IkReal x623=(new_r10*x622);
IkReal x624=((1.0)*x622);
IkReal x625=(new_r00*x621);
evalcond[0]=(((new_r01*x621))+((new_r11*x622)));
evalcond[1]=(x625+x623);
evalcond[2]=((((-1.0)*new_r00*x624))+((new_r10*x621)));
evalcond[3]=((((-1.0)*new_r01*x624))+((new_r11*x621)));
evalcond[4]=(((new_r22*x623))+((new_r22*x625)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x627 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x627.valid){
continue;
}
IkReal x626=x627.value;
j2array[0]=((-1.0)*x626);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x626)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x628=IKcos(j2);
IkReal x629=IKsin(j2);
IkReal x630=(new_r11*x629);
IkReal x631=((1.0)*x629);
IkReal x632=(new_r01*x628);
evalcond[0]=(x632+x630);
evalcond[1]=((((-1.0)*new_r00*x631))+((new_r10*x628)));
evalcond[2]=((((-1.0)*new_r01*x631))+((new_r11*x628)));
evalcond[3]=(((new_r22*x630))+((new_r22*x632)));
evalcond[4]=(((new_r00*new_r22*x628))+((new_r10*new_r22*x629)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x634 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x634.valid){
continue;
}
IkReal x633=x634.value;
j2array[0]=((-1.0)*x633);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x633)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x635=IKcos(j2);
IkReal x636=IKsin(j2);
IkReal x637=(new_r10*x636);
IkReal x638=((1.0)*x636);
IkReal x639=(new_r00*x635);
evalcond[0]=(x637+x639);
evalcond[1]=((((-1.0)*new_r00*x638))+((new_r10*x635)));
evalcond[2]=((((-1.0)*new_r01*x638))+((new_r11*x635)));
evalcond[3]=(((new_r11*new_r22*x636))+((new_r01*new_r22*x635)));
evalcond[4]=(((new_r22*x639))+((new_r22*x637)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x641=IKPowWithIntegerCheck(sj3,-1);
if(!x641.valid){
continue;
}
IkReal x640=x641.value;
CheckValue<IkReal> x642=IKPowWithIntegerCheck(cj4,-1);
if(!x642.valid){
continue;
}
if( IKabs((x640*(x642.value)*(((((-1.0)*new_r01*sj3))+(((-1.0)*cj3*new_r02*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x640)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x640*(x642.value)*(((((-1.0)*new_r01*sj3))+(((-1.0)*cj3*new_r02*sj4))))))+IKsqr((new_r02*x640))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x640*(x642.value)*(((((-1.0)*new_r01*sj3))+(((-1.0)*cj3*new_r02*sj4))))), (new_r02*x640));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x643=IKcos(j2);
IkReal x644=IKsin(j2);
IkReal x645=((1.0)*cj4);
IkReal x646=((1.0)*sj3);
IkReal x647=((1.0)*sj4);
IkReal x648=(cj3*sj4);
IkReal x649=((1.0)*cj3);
IkReal x650=(new_r01*x643);
IkReal x651=(new_r02*x643);
IkReal x652=(new_r11*x644);
IkReal x653=(cj4*x643);
IkReal x654=((1.0)*x644);
IkReal x655=(cj4*x644);
IkReal x656=(new_r10*x644);
IkReal x657=(new_r00*x643);
IkReal x658=(new_r12*x644);
evalcond[0]=((((-1.0)*x643*x646))+new_r02);
evalcond[1]=((((-1.0)*x644*x646))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x654))+((new_r12*x643)));
evalcond[3]=(((x643*x648))+x655+new_r01);
evalcond[4]=((((-1.0)*x646))+x651+x658);
evalcond[5]=(x648+x650+x652);
evalcond[6]=(((sj4*x644))+new_r00+(((-1.0)*cj3*x643*x645)));
evalcond[7]=(((x644*x648))+(((-1.0)*x643*x645))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x654))+(((-1.0)*x647))+((new_r10*x643)));
evalcond[9]=(((new_r11*x643))+(((-1.0)*x645))+(((-1.0)*new_r01*x654)));
evalcond[10]=((((-1.0)*cj3*x645))+x656+x657);
evalcond[11]=((((-1.0)*x643*x647))+new_r10+(((-1.0)*cj3*x644*x645)));
evalcond[12]=(((cj3*x651))+((cj3*x658))+(((-1.0)*new_r22*x646)));
evalcond[13]=(sj4+((cj3*x650))+((cj3*x652))+(((-1.0)*new_r21*x646)));
evalcond[14]=((((-1.0)*x646*x656))+(((-1.0)*x646*x657))+(((-1.0)*new_r20*x649)));
evalcond[15]=((((-1.0)*x646*x650))+(((-1.0)*x646*x652))+(((-1.0)*new_r21*x649)));
evalcond[16]=((1.0)+(((-1.0)*x646*x651))+(((-1.0)*x646*x658))+(((-1.0)*new_r22*x649)));
evalcond[17]=(((cj3*x656))+((cj3*x657))+(((-1.0)*x645))+(((-1.0)*new_r20*x646)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x659=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x659.valid){
continue;
}
CheckValue<IkReal> x660 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x660.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x659.value)))+(x660.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x661=IKcos(j2);
IkReal x662=IKsin(j2);
IkReal x663=((1.0)*cj4);
IkReal x664=((1.0)*sj3);
IkReal x665=((1.0)*sj4);
IkReal x666=(cj3*sj4);
IkReal x667=((1.0)*cj3);
IkReal x668=(new_r01*x661);
IkReal x669=(new_r02*x661);
IkReal x670=(new_r11*x662);
IkReal x671=(cj4*x661);
IkReal x672=((1.0)*x662);
IkReal x673=(cj4*x662);
IkReal x674=(new_r10*x662);
IkReal x675=(new_r00*x661);
IkReal x676=(new_r12*x662);
evalcond[0]=((((-1.0)*x661*x664))+new_r02);
evalcond[1]=((((-1.0)*x662*x664))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x672))+((new_r12*x661)));
evalcond[3]=(((x661*x666))+x673+new_r01);
evalcond[4]=((((-1.0)*x664))+x669+x676);
evalcond[5]=(x668+x666+x670);
evalcond[6]=(((sj4*x662))+(((-1.0)*cj3*x661*x663))+new_r00);
evalcond[7]=(((x662*x666))+(((-1.0)*x661*x663))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x672))+((new_r10*x661))+(((-1.0)*x665)));
evalcond[9]=((((-1.0)*new_r01*x672))+((new_r11*x661))+(((-1.0)*x663)));
evalcond[10]=((((-1.0)*cj3*x663))+x674+x675);
evalcond[11]=((((-1.0)*x661*x665))+new_r10+(((-1.0)*cj3*x662*x663)));
evalcond[12]=(((cj3*x676))+((cj3*x669))+(((-1.0)*new_r22*x664)));
evalcond[13]=((((-1.0)*new_r21*x664))+((cj3*x670))+sj4+((cj3*x668)));
evalcond[14]=((((-1.0)*x664*x675))+(((-1.0)*x664*x674))+(((-1.0)*new_r20*x667)));
evalcond[15]=((((-1.0)*new_r21*x667))+(((-1.0)*x664*x670))+(((-1.0)*x664*x668)));
evalcond[16]=((1.0)+(((-1.0)*x664*x676))+(((-1.0)*x664*x669))+(((-1.0)*new_r22*x667)));
evalcond[17]=(((cj3*x675))+((cj3*x674))+(((-1.0)*x663))+(((-1.0)*new_r20*x664)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x677=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x677.valid){
continue;
}
CheckValue<IkReal> x678 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x678.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x677.value)))+(x678.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x679=IKcos(j2);
IkReal x680=IKsin(j2);
IkReal x681=((1.0)*sj3);
IkReal x682=((1.0)*cj3);
IkReal x683=(new_r02*x679);
IkReal x684=(new_r12*x680);
IkReal x685=(x680*x681);
evalcond[0]=((((-1.0)*x679*x681))+new_r02);
evalcond[1]=((((-1.0)*x685))+new_r12);
evalcond[2]=(((new_r12*x679))+(((-1.0)*new_r02*x680)));
evalcond[3]=((((-1.0)*x681))+x683+x684);
evalcond[4]=((((-1.0)*new_r22*x681))+((cj3*x683))+((cj3*x684)));
evalcond[5]=((((-1.0)*new_r10*x685))+(((-1.0)*new_r20*x682))+(((-1.0)*new_r00*x679*x681)));
evalcond[6]=((((-1.0)*new_r01*x679*x681))+(((-1.0)*new_r21*x682))+(((-1.0)*new_r11*x685)));
evalcond[7]=((1.0)+(((-1.0)*x681*x683))+(((-1.0)*x681*x684))+(((-1.0)*new_r22*x682)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj2;
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=cj2;
j4eval[1]=cj3;
j4eval[2]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=cj3;
j4eval[1]=IKsign(cj3);
j4eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x686=IKsin(j4);
IkReal x687=((1.0)*(IKcos(j4)));
evalcond[0]=(x686+new_r11);
evalcond[1]=((((-1.0)*x687))+new_r10);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x686)));
evalcond[3]=((((-1.0)*x687))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x688=IKcos(j4);
IkReal x689=((1.0)*(IKsin(j4)));
evalcond[0]=(x688+new_r10);
evalcond[1]=((((-1.0)*x689))+new_r11);
evalcond[2]=((((-1.0)*x689))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x688)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x690=IKcos(j4);
IkReal x691=((1.0)*(IKsin(j4)));
evalcond[0]=(x690+new_r20);
evalcond[1]=((((-1.0)*x691))+new_r21);
evalcond[2]=((((-1.0)*x691))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x690)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x692=IKsin(j4);
IkReal x693=((1.0)*(IKcos(j4)));
evalcond[0]=(x692+new_r21);
evalcond[1]=((((-1.0)*x693))+new_r20);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x692)));
evalcond[3]=((((-1.0)*x693))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x694=IKsin(j4);
IkReal x695=IKcos(j4);
IkReal x696=((-1.0)*x695);
evalcond[0]=x694;
evalcond[1]=(new_r22*x694);
evalcond[2]=x696;
evalcond[3]=(new_r22*x696);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x694)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x695)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x697=IKPowWithIntegerCheck(sj3,-1);
if(!x697.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x697.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x697.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x697.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x698=IKsin(j4);
IkReal x699=IKcos(j4);
IkReal x700=((1.0)*sj3);
IkReal x701=((1.0)*x699);
evalcond[0]=(((sj3*x699))+new_r20);
evalcond[1]=(((cj3*x698))+new_r11);
evalcond[2]=((((-1.0)*x698*x700))+new_r21);
evalcond[3]=((((-1.0)*cj3*x701))+new_r10);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x698)));
evalcond[5]=((((-1.0)*x701))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x700))+x698+((cj3*new_r11)));
evalcond[7]=((((-1.0)*new_r20*x700))+(((-1.0)*x701))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x702=IKPowWithIntegerCheck(IKsign(cj3),-1);
if(!x702.valid){
continue;
}
CheckValue<IkReal> x703 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x703.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x702.value)))+(x703.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x704=IKsin(j4);
IkReal x705=IKcos(j4);
IkReal x706=((1.0)*sj3);
IkReal x707=((1.0)*x705);
evalcond[0]=(((sj3*x705))+new_r20);
evalcond[1]=(new_r11+((cj3*x704)));
evalcond[2]=((((-1.0)*x704*x706))+new_r21);
evalcond[3]=((((-1.0)*cj3*x707))+new_r10);
evalcond[4]=((((-1.0)*x704))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x707))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x706))+((cj3*new_r11))+x704);
evalcond[7]=((((-1.0)*new_r20*x706))+(((-1.0)*x707))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x708=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x708.valid){
continue;
}
CheckValue<IkReal> x709 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x709.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x708.value)))+(x709.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x710=IKsin(j4);
IkReal x711=IKcos(j4);
IkReal x712=((1.0)*sj3);
IkReal x713=((1.0)*x711);
evalcond[0]=(((sj3*x711))+new_r20);
evalcond[1]=(new_r11+((cj3*x710)));
evalcond[2]=((((-1.0)*x710*x712))+new_r21);
evalcond[3]=((((-1.0)*cj3*x713))+new_r10);
evalcond[4]=((((-1.0)*x710))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x713))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x712))+((cj3*new_r11))+x710);
evalcond[7]=((((-1.0)*new_r20*x712))+(((-1.0)*x713))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x714=IKcos(j4);
IkReal x715=IKsin(j4);
IkReal x716=((1.0)*sj3);
IkReal x717=((1.0)*new_r11);
IkReal x718=((1.0)*new_r10);
IkReal x719=((1.0)*x714);
evalcond[0]=(((sj3*x714))+new_r20);
evalcond[1]=((((-1.0)*x715))+new_r00);
evalcond[2]=((((-1.0)*x719))+new_r01);
evalcond[3]=(new_r21+(((-1.0)*x715*x716)));
evalcond[4]=((((-1.0)*x717))+((cj3*x715)));
evalcond[5]=((((-1.0)*cj3*x719))+(((-1.0)*x718)));
evalcond[6]=((((-1.0)*new_r21*x716))+(((-1.0)*cj3*x717))+x715);
evalcond[7]=((((-1.0)*new_r20*x716))+(((-1.0)*cj3*x718))+(((-1.0)*x719)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x720=IKcos(j4);
IkReal x721=IKsin(j4);
IkReal x722=((1.0)*sj2);
IkReal x723=((1.0)*cj2);
IkReal x724=((1.0)*x721);
evalcond[0]=(x720+new_r20);
evalcond[1]=((((-1.0)*x724))+new_r21);
evalcond[2]=(((sj2*x720))+new_r01);
evalcond[3]=(((sj2*x721))+new_r00);
evalcond[4]=((((-1.0)*x720*x723))+new_r11);
evalcond[5]=((((-1.0)*x721*x723))+new_r10);
evalcond[6]=((((-1.0)*x724))+((cj2*new_r10))+(((-1.0)*new_r00*x722)));
evalcond[7]=((((-1.0)*x720))+((cj2*new_r11))+(((-1.0)*new_r01*x722)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x725=IKcos(j4);
IkReal x726=IKsin(j4);
IkReal x727=((1.0)*sj2);
IkReal x728=((1.0)*x725);
IkReal x729=((1.0)*x726);
evalcond[0]=(x726+new_r21);
evalcond[1]=((((-1.0)*x728))+new_r20);
evalcond[2]=(((sj2*x725))+new_r01);
evalcond[3]=(((sj2*x726))+new_r00);
evalcond[4]=((((-1.0)*cj2*x728))+new_r11);
evalcond[5]=((((-1.0)*cj2*x729))+new_r10);
evalcond[6]=((((-1.0)*x729))+((cj2*new_r10))+(((-1.0)*new_r00*x727)));
evalcond[7]=((((-1.0)*x728))+((cj2*new_r11))+(((-1.0)*new_r01*x727)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x730=((1.0)*sj2);
if( IKabs(((((-1.0)*cj2*new_r01))+(((-1.0)*new_r00*x730)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*new_r00))+(((-1.0)*new_r01*x730)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj2*new_r01))+(((-1.0)*new_r00*x730))))+IKsqr((((cj2*new_r00))+(((-1.0)*new_r01*x730))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj2*new_r01))+(((-1.0)*new_r00*x730))), (((cj2*new_r00))+(((-1.0)*new_r01*x730))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x731=IKsin(j4);
IkReal x732=IKcos(j4);
IkReal x733=((1.0)*sj2);
IkReal x734=((1.0)*x732);
IkReal x735=(sj2*x731);
IkReal x736=(cj2*x731);
IkReal x737=(cj2*x734);
evalcond[0]=(((new_r11*sj2))+((cj2*new_r01))+x731);
evalcond[1]=(((sj2*x732))+x736+new_r01);
evalcond[2]=(((new_r10*sj2))+(((-1.0)*x734))+((cj2*new_r00)));
evalcond[3]=((((-1.0)*x731))+((cj2*new_r10))+(((-1.0)*new_r00*x733)));
evalcond[4]=((((-1.0)*x734))+((cj2*new_r11))+(((-1.0)*new_r01*x733)));
evalcond[5]=((((-1.0)*x737))+x735+new_r00);
evalcond[6]=((((-1.0)*x737))+x735+new_r11);
evalcond[7]=((((-1.0)*x732*x733))+(((-1.0)*x736))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x738=((1.0)*new_r00);
if( IKabs((((cj2*new_r01))+(((-1.0)*sj2*x738)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x738)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*new_r01))+(((-1.0)*sj2*x738))))+IKsqr(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x738))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj2*new_r01))+(((-1.0)*sj2*x738))), ((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x738))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x739=IKcos(j4);
IkReal x740=IKsin(j4);
IkReal x741=((1.0)*sj2);
IkReal x742=((1.0)*cj2);
IkReal x743=((1.0)*x740);
IkReal x744=(sj2*x739);
IkReal x745=(x740*x742);
evalcond[0]=(((new_r10*sj2))+((cj2*new_r00))+x739);
evalcond[1]=(((new_r11*sj2))+((cj2*new_r01))+(((-1.0)*x743)));
evalcond[2]=(((cj2*x739))+((sj2*x740))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x741))+((cj2*new_r10))+(((-1.0)*x743)));
evalcond[4]=((((-1.0)*new_r01*x741))+(((-1.0)*x739))+((cj2*new_r11)));
evalcond[5]=(x744+new_r01+(((-1.0)*x745)));
evalcond[6]=(x744+new_r10+(((-1.0)*x745)));
evalcond[7]=((((-1.0)*x740*x741))+(((-1.0)*x739*x742))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x746=IKcos(j4);
IkReal x747=IKsin(j4);
IkReal x748=((1.0)*sj3);
IkReal x749=((1.0)*x746);
evalcond[0]=(((sj3*x746))+new_r20);
evalcond[1]=((((-1.0)*x747))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x749)));
evalcond[3]=(((cj3*x747))+new_r01);
evalcond[4]=((((-1.0)*x747*x748))+new_r21);
evalcond[5]=((((-1.0)*cj3*x749))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x748))+((cj3*new_r01))+x747);
evalcond[7]=((((-1.0)*new_r20*x748))+((cj3*new_r00))+(((-1.0)*x749)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=cj3;
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x750=IKcos(j4);
IkReal x751=((1.0)*(IKsin(j4)));
evalcond[0]=(x750+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x751)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x751)));
evalcond[3]=((((-1.0)*x750))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x752=IKsin(j4);
IkReal x753=((1.0)*(IKcos(j4)));
evalcond[0]=(x752+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x753)));
evalcond[2]=((((-1.0)*x752))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x753)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x754=IKsin(j4);
IkReal x755=((1.0)*(IKcos(j4)));
evalcond[0]=((((-1.0)*new_r01))+x754);
evalcond[1]=((((-1.0)*x754))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x755)));
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x755)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x756=IKcos(j4);
IkReal x757=((1.0)*(IKsin(j4)));
evalcond[0]=((((-1.0)*new_r00))+x756);
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x757)));
evalcond[2]=((((-1.0)*x756))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x757)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x758=IKsin(j4);
IkReal x759=IKcos(j4);
IkReal x760=((-1.0)*x759);
evalcond[0]=x758;
evalcond[1]=(new_r22*x758);
evalcond[2]=x760;
evalcond[3]=(new_r22*x760);
evalcond[4]=((((-1.0)*x758))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x759))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x761=IKPowWithIntegerCheck(cj3,-1);
if(!x761.valid){
continue;
}
CheckValue<IkReal> x762=IKPowWithIntegerCheck(sj3,-1);
if(!x762.valid){
continue;
}
if( IKabs((new_r01*(x761.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x762.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x761.value)))+IKsqr(((-1.0)*new_r20*(x762.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r01*(x761.value)), ((-1.0)*new_r20*(x762.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x763=IKsin(j4);
IkReal x764=IKcos(j4);
IkReal x765=((1.0)*new_r00);
IkReal x766=((1.0)*sj3);
IkReal x767=((1.0)*new_r01);
IkReal x768=((1.0)*x764);
evalcond[0]=(((sj3*x764))+new_r20);
evalcond[1]=((((-1.0)*x763*x766))+new_r21);
evalcond[2]=((((-1.0)*x763))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x768))+(((-1.0)*new_r11)));
evalcond[4]=(((cj3*x763))+(((-1.0)*x767)));
evalcond[5]=((((-1.0)*cj3*x768))+(((-1.0)*x765)));
evalcond[6]=((((-1.0)*cj3*x767))+x763+(((-1.0)*new_r21*x766)));
evalcond[7]=((((-1.0)*new_r20*x766))+(((-1.0)*cj3*x765))+(((-1.0)*x768)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x769=IKPowWithIntegerCheck(sj3,-1);
if(!x769.valid){
continue;
}
if( IKabs((new_r21*(x769.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x769.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r21*(x769.value)), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x770=IKsin(j4);
IkReal x771=IKcos(j4);
IkReal x772=((1.0)*new_r00);
IkReal x773=((1.0)*sj3);
IkReal x774=((1.0)*new_r01);
IkReal x775=((1.0)*x771);
evalcond[0]=(((sj3*x771))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x770*x773)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x770)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x775)));
evalcond[4]=(((cj3*x770))+(((-1.0)*x774)));
evalcond[5]=((((-1.0)*cj3*x775))+(((-1.0)*x772)));
evalcond[6]=((((-1.0)*cj3*x774))+(((-1.0)*new_r21*x773))+x770);
evalcond[7]=((((-1.0)*cj3*x772))+(((-1.0)*new_r20*x773))+(((-1.0)*x775)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x776=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x776.valid){
continue;
}
CheckValue<IkReal> x777 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x777.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x776.value)))+(x777.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x778=IKsin(j4);
IkReal x779=IKcos(j4);
IkReal x780=((1.0)*new_r00);
IkReal x781=((1.0)*sj3);
IkReal x782=((1.0)*new_r01);
IkReal x783=((1.0)*x779);
evalcond[0]=(((sj3*x779))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x778*x781)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x778)));
evalcond[3]=((((-1.0)*x783))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x782))+((cj3*x778)));
evalcond[5]=((((-1.0)*cj3*x783))+(((-1.0)*x780)));
evalcond[6]=((((-1.0)*new_r21*x781))+(((-1.0)*cj3*x782))+x778);
evalcond[7]=((((-1.0)*cj3*x780))+(((-1.0)*x783))+(((-1.0)*new_r20*x781)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j4eval[0]=IKabs(new_r22);
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j4array[2], cj4array[2], sj4array[2], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[2]={true,true};
_nj4 = 2;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x785=IKPowWithIntegerCheck(sj3,-1);
if(!x785.valid){
continue;
}
IkReal x784=x785.value;
CheckValue<IkReal> x786=IKPowWithIntegerCheck(cj2,-1);
if(!x786.valid){
continue;
}
CheckValue<IkReal> x787=IKPowWithIntegerCheck(cj3,-1);
if(!x787.valid){
continue;
}
if( IKabs((x784*(x786.value)*(x787.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x784)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x784*(x786.value)*(x787.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3))))))+IKsqr(((-1.0)*new_r20*x784))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x784*(x786.value)*(x787.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3))))), ((-1.0)*new_r20*x784));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x788=IKsin(j4);
IkReal x789=IKcos(j4);
IkReal x790=(cj2*new_r01);
IkReal x791=(new_r10*sj2);
IkReal x792=((1.0)*sj3);
IkReal x793=((1.0)*sj2);
IkReal x794=(new_r11*sj2);
IkReal x795=(cj2*new_r00);
IkReal x796=((1.0)*x789);
IkReal x797=(sj2*x788);
IkReal x798=(cj2*x788);
evalcond[0]=(new_r20+((sj3*x789)));
evalcond[1]=((((-1.0)*x788*x792))+new_r21);
evalcond[2]=(x790+x794+((cj3*x788)));
evalcond[3]=(((cj2*new_r10))+(((-1.0)*x788))+(((-1.0)*new_r00*x793)));
evalcond[4]=((((-1.0)*new_r01*x793))+(((-1.0)*x796))+((cj2*new_r11)));
evalcond[5]=(((sj2*x789))+new_r01+((cj3*x798)));
evalcond[6]=((((-1.0)*cj3*x796))+x791+x795);
evalcond[7]=((((-1.0)*cj2*cj3*x796))+x797+new_r00);
evalcond[8]=((((-1.0)*cj2*x796))+new_r11+((cj3*x797)));
evalcond[9]=((((-1.0)*cj3*x789*x793))+(((-1.0)*x798))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x792))+x788+((cj3*x790))+((cj3*x794)));
evalcond[11]=((((-1.0)*x796))+((cj3*x791))+((cj3*x795))+(((-1.0)*new_r20*x792)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x800=IKPowWithIntegerCheck(sj3,-1);
if(!x800.valid){
continue;
}
IkReal x799=x800.value;
CheckValue<IkReal> x801=IKPowWithIntegerCheck(sj2,-1);
if(!x801.valid){
continue;
}
if( IKabs((x799*(x801.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x799)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x799*(x801.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3))))))+IKsqr(((-1.0)*new_r20*x799))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x799*(x801.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3))))), ((-1.0)*new_r20*x799));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x802=IKsin(j4);
IkReal x803=IKcos(j4);
IkReal x804=(cj2*new_r01);
IkReal x805=(new_r10*sj2);
IkReal x806=((1.0)*sj3);
IkReal x807=((1.0)*sj2);
IkReal x808=(new_r11*sj2);
IkReal x809=(cj2*new_r00);
IkReal x810=((1.0)*x803);
IkReal x811=(sj2*x802);
IkReal x812=(cj2*x802);
evalcond[0]=(((sj3*x803))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x802*x806)));
evalcond[2]=(((cj3*x802))+x808+x804);
evalcond[3]=((((-1.0)*x802))+(((-1.0)*new_r00*x807))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x807))+(((-1.0)*x810))+((cj2*new_r11)));
evalcond[5]=(((sj2*x803))+((cj3*x812))+new_r01);
evalcond[6]=((((-1.0)*cj3*x810))+x809+x805);
evalcond[7]=((((-1.0)*cj2*cj3*x810))+new_r00+x811);
evalcond[8]=((((-1.0)*cj2*x810))+((cj3*x811))+new_r11);
evalcond[9]=((((-1.0)*x812))+(((-1.0)*cj3*x803*x807))+new_r10);
evalcond[10]=(((cj3*x808))+((cj3*x804))+x802+(((-1.0)*new_r21*x806)));
evalcond[11]=((((-1.0)*new_r20*x806))+(((-1.0)*x810))+((cj3*x809))+((cj3*x805)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x813=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x813.valid){
continue;
}
CheckValue<IkReal> x814 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x814.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x813.value)))+(x814.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x815=IKsin(j4);
IkReal x816=IKcos(j4);
IkReal x817=(cj2*new_r01);
IkReal x818=(new_r10*sj2);
IkReal x819=((1.0)*sj3);
IkReal x820=((1.0)*sj2);
IkReal x821=(new_r11*sj2);
IkReal x822=(cj2*new_r00);
IkReal x823=((1.0)*x816);
IkReal x824=(sj2*x815);
IkReal x825=(cj2*x815);
evalcond[0]=(((sj3*x816))+new_r20);
evalcond[1]=((((-1.0)*x815*x819))+new_r21);
evalcond[2]=(((cj3*x815))+x817+x821);
evalcond[3]=((((-1.0)*new_r00*x820))+(((-1.0)*x815))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*x823))+(((-1.0)*new_r01*x820))+((cj2*new_r11)));
evalcond[5]=(((sj2*x816))+new_r01+((cj3*x825)));
evalcond[6]=(x818+x822+(((-1.0)*cj3*x823)));
evalcond[7]=((((-1.0)*cj2*cj3*x823))+new_r00+x824);
evalcond[8]=(new_r11+((cj3*x824))+(((-1.0)*cj2*x823)));
evalcond[9]=((((-1.0)*cj3*x816*x820))+(((-1.0)*x825))+new_r10);
evalcond[10]=(((cj3*x817))+(((-1.0)*new_r21*x819))+x815+((cj3*x821)));
evalcond[11]=(((cj3*x818))+(((-1.0)*x823))+(((-1.0)*new_r20*x819))+((cj3*x822)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - mantra (76c6f2aa46523e565c4b4519a1b97e14)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
